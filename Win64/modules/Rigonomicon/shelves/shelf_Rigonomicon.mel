global proc shelf_Rigonomicon () {
    global string $gBuffStr;
    global string $gBuffStr0;
    global string $gBuffStr1;


    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Bacon-Strip Useful Editors and About" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Editors" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "Editors" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "baconstrip_shelf.png" 
        -image1 "baconstrip_shelf.png" 
        -style "iconOnly" 
        -marginWidth 0
        -marginHeight 1
        -command "NodeEditorWindow" 
        -sourceType "mel" 
        -doubleClickCommand "PluginManager" 
        -commandRepeatable 1
        -flat 1
        -mi "About Bacon-Strip" ( "\nimport maya.cmds as cmds\n\ndef CreateAbout():\n\tif cmds.window('AboutBaconStrip', exists=True):\n\t\tcmds.deleteUI('AboutBaconStrip')\n\tbaconPath = cmds.getModulePath(moduleName='Bacon')\n\tbaconIcon = baconPath + '/Bacon/icons/baconstrip_shelf.png'\n\tcmds.window('AboutBaconStrip', title='About Bacon-Strip', sizeable=False, widthHeight=(450, 115) )\n\tcmds.columnLayout( adjustableColumn=True, columnAlign='center' )\n\tcmds.text('\\nBacon-Strip [Bake and Strip]', backgroundColor=(.5,.2,0.2))\n\tcmds.text('Pre-Release ver. 0.3.0', backgroundColor=(.8,.5,.5))\n\tcmds.text('July 14th, 2024', backgroundColor=(.7,0.65,0.4))\n\tcmds.text(' ', backgroundColor=(.8,.5,.5))\n\tcmds.text('\\n', backgroundColor=(.5,0.2,0.2))\n\tcmds.button(label='Close', command='cmds.deleteUI(\"AboutBaconStrip\")')\n\tcmds.showWindow('AboutBaconStrip')\n\t\t\nCreateAbout()\n\n\n\n\n" )
        -mip 0
        -mi "Plugin Manager" ( "PluginManager" )
        -mi "Namespace Editor" ( "NamespaceEditor" )
        -mi "Node Editor" ( "NodeEditorWindow" )
        -mi "Reference Editor" ( "ReferenceEditor" )
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Clean Up Tools" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Clean" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "Clean" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "baconstripCyan_shelf.png" 
        -image1 "baconstripCyan_shelf.png" 
        -style "iconOnly" 
        -marginWidth 0
        -marginHeight 1
        -command "\n" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
        -mi "Delete History" ( "DeleteHistory" )
        -mi "Reconstruct Hierarchy (select root)" ( "# Rebuild Hierarchy - Cmds method.\nimport maya.cmds as cmds\n\ndef createDupSubs (_node, _newParentNode):\n\tdupname = cmds.ls(_node)[0]\n\trenamedNode = cmds.rename(_node, dupname + '_old')\n\tdup = cmds.createNode('joint', n=dupname)\n\ttrans = cmds.xform(renamedNode, ws=True, t=True, query=True)\n\trot = cmds.xform(renamedNode, ws=True, ro=True, query=True)\n\tcmds.xform(dup, ws=True, t=trans)\n\tcmds.xform(dup, ws=True, ro=rot)\n\tif _newParentNode != None:\n\t\tcmds.parent(dup, _newParentNode)\n\tchildren = cmds.listRelatives(renamedNode, children=True, type=['joint', 'transform'])\n\tif children != None:\n\t\tfor c in children:\n\t\t\tcreateDupSubs(c, dup)\n\nrootNodeToDup = cmds.ls(absoluteName=True, orderedSelection=True, type=['joint','transform'])\ncreateDupSubs(rootNodeToDup, None)\n" )
        -mip 1
        -mi "Report Scaling (selection)" ( "# CMDS Method\nimport maya.cmds as cmds\n\nthisFilename = os.path.basename(cmds.file(q=True, sn=True))\nprint('Result for: \\\"' + thisFilename + '\\\"')\nSel = cmds.ls(an=True, dag=True, os=True, type=['joint','transform'])\nScaledObjects = 0\nfor k in Sel:\n\tthisScale = cmds.xform(k, relative=True, scale=True, query=True)\n\tthisScaleTotal = thisScale[0] + thisScale[1] + thisScale[2]\n\tif thisScaleTotal > 3.00000001 or thisScaleTotal < 2.999999999:\n\t\tprint(k + '.Scale >>  ' + thisScale.__str__())\n\t\tScaledObjects += 1\ncmds.inViewMessage( amg=('Found <hl>' + ScaledObjects.__str__() + '</hl> scaled objects.\\nSee messages for details.'), pos='midCenterTop', fade=True, fadeOutTime=10 )\n\n\n" )
        -mip 2
        -mi "Fix Old Bacon-Shapes" ( "# CMDS Method\nimport maya.cmds as cmds\n\nif cmds.pluginInfo('baconShapeBone', query=True, loaded=True) == False:\n\tcmds.loadPlugin('baconShapeBone')\n\nAllBaconShapes = cmds.ls(an=True, type='baconShapeBone')\nfor bshape in AllBaconShapes:\n\tcmds.setAttr(bshape + '.shapeSizeX', cmds.getAttr(bshape + '.localScaleX'))\n\tcmds.setAttr(bshape + '.shapeSizeY', cmds.getAttr(bshape + '.localScaleY'))\n\tcmds.setAttr(bshape + '.shapeSizeZ', cmds.getAttr(bshape + '.localScaleZ'))\n\tcmds.setAttr(bshape + '.shapeOffsetX', cmds.getAttr(bshape + '.localPositionX'))\n\tcmds.setAttr(bshape + '.shapeOffsetY', cmds.getAttr(bshape + '.localPositionY'))\n\tcmds.setAttr(bshape + '.shapeOffsetZ', cmds.getAttr(bshape + '.localPositionZ'))\n\tcmds.setAttr(bshape + '.shapeOrientationX', cmds.getAttr(bshape + '.localRotationX'))\n\tcmds.setAttr(bshape + '.shapeOrientationY', cmds.getAttr(bshape + '.localRotationY'))\n\tcmds.setAttr(bshape + '.shapeOrientationZ', cmds.getAttr(bshape + '.localRotationZ'))\n\tif cmds.getAttr(bshape + '.mirror') == True:\n\t\tcmds.setAttr(bshape + '.shapeSizeY', cmds.getAttr(bshape + '.shapeSizeY') * -1.0)\n\t\tcmds.setAttr(bshape + '.shapeSizeZ', cmds.getAttr(bshape + '.shapeSizeZ') * -1.0)\n\n\n" )
        -mip 3
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Toggle local rotation axis visibility" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Local Rotation Axes" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "srt_M.png" 
        -image1 "srt_M.png" 
        -style "iconOnly" 
        -marginWidth 0
        -marginHeight 1
        -command "ToggleLocalRotationAxes" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
        -mi "Set all Local Rotation Axes [ON]" ( "# CMDS Method\nimport maya.cmds as cmds\nSel = cmds.ls(absoluteName=True, orderedSelection=True, type=['joint','transform'])\nfor k in Sel:\n\tcmds.setAttr(k + '.displayLocalAxis', True)\n\n\n" )
        -mip 0
        -mi "Set all Local Rotation Axes [OFF]" ( "# CMDS Method\nimport maya.cmds as cmds\nSel = cmds.ls(absoluteName=True, orderedSelection=True, type=['joint','transform'])\nfor k in Sel:\n\tcmds.setAttr(k + '.displayLocalAxis', False)\n\n" )
        -mip 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Create a locator object on the grid" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Locators" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "locator.png" 
        -image1 "locator.png" 
        -style "iconOnly" 
        -marginWidth 0
        -marginHeight 1
        -command "# CMDS Method\nimport maya.cmds as cmds\nif cmds.pluginInfo('baconShapeBone', query=True, loaded=True) == False:\n\tcmds.loadPlugin('baconShapeBone')\nnewJoint = cmds.createNode('joint', n='baconJoint')\ncmds.setAttr(newJoint + '.drawStyle', 2)\nshapeName = cmds.ls(newJoint, shortNames=True)[0] + '_Shape'\nboneShape = cmds.createNode('baconShapeBone', parent=newJoint, n=shapeName)\ncmds.setAttr(boneShape + '.shapeType', 7)\ncmds.setAttr(boneShape + '.xRay', 1)\ncmds.color( newJoint, ud=6 )\ncmds.select(newJoint)\n" 
        -sourceType "python" 
        -commandRepeatable 1
        -flat 1
        -mi "Default Locator" ( "CreateLocator;" )
        -mi "Locator Joint" ( "import maya.cmds as cmds\nnewJoint = cmds.createNode('joint', n='locatorJoint')\ncmds.setAttr(newJoint + '.drawStyle', 2)\nshapeName = cmds.ls(newJoint, shortNames=True)[0] + '_Shape'\ncmds.createNode('locator', parent=newJoint, name=shapeName)\ncmds.select(newJoint)\n" )
        -mip 1
        -mi "Bacon Joint [BSPLUG]" ( "# CMDS Method\nimport maya.cmds as cmds\nif cmds.pluginInfo('baconShapeBone', query=True, loaded=True) == False:\n\tcmds.loadPlugin('baconShapeBone')\nnewJoint = cmds.createNode('joint', n='baconJoint')\ncmds.setAttr(newJoint + '.drawStyle', 2)\nshapeName = cmds.ls(newJoint, shortNames=True)[0] + '_Shape'\nboneShape = cmds.createNode('baconShapeBone', parent=newJoint, n=shapeName)\ncmds.setAttr(boneShape + '.shapeType', 7)\ncmds.setAttr(boneShape + '.xRay', 1)\ncmds.color( newJoint, ud=6 )\ncmds.select(newJoint)\n" )
        -mip 2
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Click to place joint, click on existing joint to add to skeleton, click/drag to position joint" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Create Joints" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "kinJoint.png" 
        -image1 "kinJoint.png" 
        -style "iconOnly" 
        -marginWidth 0
        -marginHeight 1
        -command "JointTool" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Match All Transforms Options" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Match" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "Match" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "vectorProduct.svg" 
        -image1 "vectorProduct.svg" 
        -style "iconOnly" 
        -marginWidth 0
        -marginHeight 1
        -command "import maya.mel as mel\nmel.eval( 'MatchTransformOptions;')" 
        -sourceType "python" 
        -doubleClickCommand "import pymel.core as pm\npm.matchTransform(pos=True, rot=True)" 
        -commandRepeatable 1
        -flat 1
        -mi "Match Translation" ( "# CMDS Method\nimport maya.cmds as cmds\nxForms = ['joint','transform']\nSel = cmds.ls(absoluteName=True, orderedSelection=True, type=xForms)\nMatchObj = Sel[0]\nChildren = cmds.listRelatives(MatchObj, children=True, type=xForms)\nChildrenTMs = []\nif Children != None:\n\tfor c in Children:\n\t\tChildrenTMs.append(cmds.xform(c, matrix=True, worldSpace=True, query=True))\ncmds.matchTransform(pos=True, rot=False)\nif cmds.manipMoveContext('Move', q=True, pcp=True):\n\tfor i in range( len(Children) ):\n\t\tcmds.xform(Children[i], matrix=ChildrenTMs[i], worldSpace=True)\n" )
        -mip 0
        -mi "Match Rotation" ( "# CMDS Method\nimport maya.cmds as cmds\nxForms = ['joint','transform']\nSel = cmds.ls(absoluteName=True, orderedSelection=True, type=xForms)\nMatchObj = Sel[0]\nChildren = cmds.listRelatives(MatchObj, children=True, type=xForms)\nChildrenTMs = []\nif Children != None:\n\tfor c in Children:\n\t\tChildrenTMs.append(cmds.xform(c, matrix=True, worldSpace=True, query=True))\ncmds.matchTransform(pos=False, rot=True)\nif cmds.manipMoveContext('Move', q=True, pcp=True):\n\tfor i in range( len(Children) ):\n\t\tcmds.xform(Children[i], matrix=ChildrenTMs[i], worldSpace=True)\n" )
        -mip 1
        -mi "Match Translation and Rotation" ( "# CMDS Method\nimport maya.cmds as cmds\nxForms = ['joint','transform']\nSel = cmds.ls(absoluteName=True, orderedSelection=True, type=xForms)\nMatchObj = Sel[0]\nChildrenTMs = []\nChildren = cmds.listRelatives(MatchObj, children=True, type=xForms)\nif Children != None:\n\tfor c in Children:\n\t\tChildrenTMs.append(cmds.xform(c, matrix=True, worldSpace=True, query=True))\ncmds.matchTransform(pos=True, rot=True)\nif cmds.manipMoveContext('Move', q=True, pcp=True):\n\tfor i in range( len(Children) ):\n\t\tcmds.xform(Children[i], matrix=ChildrenTMs[i], worldSpace=True)\n" )
        -mip 2
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Freeze transformation options" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Freeze" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "Freeze" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "FreezeTransform.png" 
        -image1 "FreezeTransform.png" 
        -style "iconOnly" 
        -marginWidth 0
        -marginHeight 1
        -command "FreezeTransformationsOptions" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
        -mi "Zero by Joint Orient" ( "import maya.cmds as cmds\nimport maya.api.OpenMaya as om\nxForms = ['joint','transform']\nfor k in cmds.ls(absoluteName=True, orderedSelection=True, type=xForms):\n\toffsetParentMatrix = cmds.getAttr(k + '.offsetParentMatrix')\n\tlocalMatrix = cmds.xform(k, matrix=True, objectSpace=True, query=True)\n\tlocalMMatrix = om.MMatrix(localMatrix) * om.MMatrix(offsetParentMatrix)\n\tlocalMTM = om.MTransformationMatrix(localMMatrix)\n\tlocalPosition = localMTM.translation(om.MSpace.kTransform)\n\tcmds.setAttr(k + '.offsetParentMatrix', om.MMatrix(), type='matrix')\n\tcmds.setAttr(k + '.translateX', localPosition.x)\n\tcmds.setAttr(k + '.translateY', localPosition.y)\n\tcmds.setAttr(k + '.translateZ', localPosition.z)\n\tcmds.setAttr(k + '.rotateX', 0)\n\tcmds.setAttr(k + '.rotateY', 0)\n\tcmds.setAttr(k + '.rotateZ', 0)\n\tcmds.setAttr(k + '.jointOrientX', om.MAngle(localMTM.rotation().x).asDegrees())\n\tcmds.setAttr(k + '.jointOrientY', om.MAngle(localMTM.rotation().y).asDegrees())\n\tcmds.setAttr(k + '.jointOrientZ', om.MAngle(localMTM.rotation().z).asDegrees())\n\t\n" )
        -mip 0
        -mi "Zero by Parent Offset Matrix" ( "# CMDS Method\nimport maya.cmds as cmds\nimport maya.api.OpenMaya as om\nxForms = ['joint','transform']\nfor k in cmds.ls(absoluteName=True, orderedSelection=True, type=xForms):\n\toffsetParentMatrix = cmds.getAttr(k + '.offsetParentMatrix')\n\tlocalMatrix = cmds.xform(k, matrix=True, objectSpace=True, query=True)\n\tlocalMMatrix = om.MMatrix(localMatrix) * om.MMatrix(offsetParentMatrix)\n\tcmds.setAttr(k + '.offsetParentMatrix', localMMatrix, type='matrix')\n\tcmds.setAttr(k + '.translateX', 0)\n\tcmds.setAttr(k + '.translateY', 0)\n\tcmds.setAttr(k + '.translateZ', 0)\n\tcmds.setAttr(k + '.rotateX', 0)\n\tcmds.setAttr(k + '.rotateY', 0)\n\tcmds.setAttr(k + '.rotateZ', 0)\n\tif cmds.objectType(k) == 'joint':\n\t\tcmds.setAttr(k + '.jointOrientX', 0)\n\t\tcmds.setAttr(k + '.jointOrientY', 0)\n\t\tcmds.setAttr(k + '.jointOrientZ', 0)" )
        -mip 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Freeze Rotation and Set JointOrient" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Alignments" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "Align" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "baconstripMag_shelf.png" 
        -image1 "baconstripMag_shelf.png" 
        -style "iconOnly" 
        -marginWidth 0
        -marginHeight 1
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
        -mi "Maya Joint Orient Tool" ( "OrientJointOptions" )
        -mi "Mirror Transfer (Slalom)" ( "import maya.cmds as cmds\nimport maya.api.OpenMaya as om\nxForms = ['joint','transform']\nsel = cmds.ls(absoluteName=True, orderedSelection=True, type=xForms)\nfor i in range(0, len(sel), 2):\n\tif (i + 1) <= len(sel):\n\t\ttm = cmds.xform(sel[i], query=True, matrix=True, worldSpace=True)\n\t\tflipMatrix = [1,-1,-1,1,  1,-1,-1,1,  1,-1,-1,1,  -1,1,1,1]\n\t\tfor j in range(16):\n\t\t\ttm[j] *= flipMatrix[j]\n\t\t# store children if to be preserved\n\t\tChildren = cmds.listRelatives(sel[i+1], children=True, type=xForms)\n\t\tChildrenTMs = []\n\t\tif Children == None:\n\t\t\tChildren = []\n\t\tfor c in Children:\n\t\t\tChildrenTMs.append(cmds.xform(c, matrix=True, worldSpace=True, query=True))\n\t\t# command\n\t\tcmds.xform(sel[i+1], worldSpace=True, matrix=tm)\n\t\t# preserve children\n\t\tif cmds.manipMoveContext('Move', q=True, pcp=True):\n\t\t\tfor c in range( len(Children) ):\n\t\t\t\tcmds.xform(Children[c], matrix=ChildrenTMs[c], worldSpace=True)\n\n" )
        -mip 1
        -mi "Re-Align Parent X-Axis" ( "# CMDS Method\nimport maya.cmds as cmds\nimport maya.api.OpenMaya as om\n\nxForms = ['joint','transform']\nSel = cmds.ls(absoluteName=True, orderedSelection=True, type=xForms)\nfor _node in Sel:\n\t_parentNode = cmds.listRelatives(_node, parent=True, path=True, type=xForms)[0]\n\t_siblings = cmds.listRelatives(_parentNode, children=True, path=True, type=xForms)\n\t_siblingTMs = []\n\tfor i in range( len(_siblings) ):\n\t\t_siblingTMs.append( cmds.xform(_siblings[i], matrix=True, query=True, worldSpace=True) )\n\t_nodeTM = cmds.xform(_node, matrix=True, query=True, worldSpace=True)\n\t_parentTM = cmds.xform(_parentNode, matrix=True, query=True, worldSpace=True)\n\t_nodePos = om.MVector(_nodeTM[12], _nodeTM[13], _nodeTM[14])\n\t_parentPos = om.MVector(_parentTM[12], _parentTM[13], _parentTM[14])\n\tXaxis = _nodePos - _parentPos\n\tdistanceToParent = Xaxis.length()\n\tXaxis.normalize()\n\tXparent = om.MVector(_parentTM[0], _parentTM[1], _parentTM[2])\n\tYparent = om.MVector(_parentTM[4], _parentTM[5], _parentTM[6])\n\tZparent = om.MVector(_parentTM[8], _parentTM[9], _parentTM[10])\n\tboneDirection = 1.0\n\tif (Xparent*Xaxis) < 0:\n\t\tXaxis *= -1.0\n\t\tboneDirection = -1.0\n\tYaxis = Zparent^Xaxis\n\tYaxis.normalize()\n\tZaxis = Xaxis^Yaxis\n\tZaxis.normalize()\n\trealignedParentTM = [Xaxis.x,Xaxis.y,Xaxis.z,0.0, Yaxis.x,Yaxis.y,Yaxis.z,0.0,  Zaxis.x,Zaxis.y,Zaxis.z,0.0, _parentTM[12],_parentTM[13],_parentTM[14],_parentTM[15]]\n\tcmds.xform(_parentNode, matrix=realignedParentTM, worldSpace=True)\n\tfor i in range( len(_siblings) ):\n\t\tcmds.xform(_siblings[i], matrix=_siblingTMs[i], worldSpace=True)\n\t#Joint Orient cleanup\n\tfor k in [_parentNode, _node]:\n\t\tif cmds.objectType(k) == 'joint':\n\t\t\toffsetParentMatrix = cmds.getAttr(k + '.offsetParentMatrix')\n\t\t\tlocalMatrix = cmds.xform(k, matrix=True, objectSpace=True, query=True)\n\t\t\tlocalMMatrix = om.MMatrix(localMatrix) * om.MMatrix(offsetParentMatrix)\n\t\t\tlocalMTM = om.MTransformationMatrix(localMMatrix)\n\t\t\tlocalPosition = localMTM.translation(om.MSpace.kTransform)\n\t\t\tcmds.setAttr(k + '.offsetParentMatrix', om.MMatrix(), type='matrix')\n\t\t\tcmds.setAttr(k + '.translateX', localPosition.x)\n\t\t\tcmds.setAttr(k + '.translateY', localPosition.y)\n\t\t\tcmds.setAttr(k + '.translateZ', localPosition.z)\n\t\t\tcmds.setAttr(k + '.rotateX', 0)\n\t\t\tcmds.setAttr(k + '.rotateY', 0)\n\t\t\tcmds.setAttr(k + '.rotateZ', 0)\n\t\t\tcmds.setAttr(k + '.jointOrientX', om.MAngle(localMTM.rotation().x).asDegrees())\n\t\t\tcmds.setAttr(k + '.jointOrientY', om.MAngle(localMTM.rotation().y).asDegrees())\n\t\t\tcmds.setAttr(k + '.jointOrientZ', om.MAngle(localMTM.rotation().z).asDegrees())\n\tboneShapes = cmds.listRelatives(_parentNode, children=True, type='baconShapeBone')\n\tif boneShapes != None:\n\t\tfor s in boneShapes:\n\t\t\tcmds.setAttr(s+'.shapeSizeX', distanceToParent * boneDirection)\n" )
        -mip 2
        -mi "Re-Align to Parent Z-Axis" ( "# CMDS Method\nimport maya.cmds as cmds\nimport maya.api.OpenMaya as om\n\nxForms = ['joint','transform']\nSel = cmds.ls(absoluteName=True, orderedSelection=True, type=xForms)\nfor _node in Sel:\n\t_parentNode = cmds.listRelatives(_node, parent=True, path=True, type=xForms)[0]\n\t_children = cmds.listRelatives(_node, children=True, path=True, type=xForms)\n\t_childrenTMs = []\n\tfor i in range( len(_children) ):\n\t\t_childrenTMs.append( cmds.xform(_children[i], matrix=True, query=True, worldSpace=True) )\n\t_nodeTM = cmds.xform(_node, matrix=True, query=True, worldSpace=True)\n\t_parentTM = cmds.xform(_parentNode, matrix=True, query=True, worldSpace=True)\n\tXaxis = om.MVector(_nodeTM[0], _nodeTM[1], _nodeTM[2])\n\tZparent = om.MVector(_parentTM[8], _parentTM[9], _parentTM[10])\n\tYaxis = Zparent^Xaxis\n\tYaxis.normalize()\n\tZaxis = Xaxis^Yaxis\n\tZaxis.normalize()\n\trealignedNodeTM = [Xaxis.x,Xaxis.y,Xaxis.z,0.0, Yaxis.x,Yaxis.y,Yaxis.z,0.0,  Zaxis.x,Zaxis.y,Zaxis.z,0.0, _nodeTM[12],_nodeTM[13],_nodeTM[14],_nodeTM[15]]\n\tcmds.xform(_node, matrix=realignedNodeTM, worldSpace=True)\n\tfor i in range( len(_children) ):\n\t\tcmds.xform(_children[i], matrix=_childrenTMs[i], worldSpace=True)\n\t#Joint Orient cleanup\n\t_children.append(_node)\n\tfor k in _children:\n\t\tif cmds.objectType(k) == 'joint':\n\t\t\toffsetParentMatrix = cmds.getAttr(k + '.offsetParentMatrix')\n\t\t\tlocalMatrix = cmds.xform(k, matrix=True, objectSpace=True, query=True)\n\t\t\tlocalMMatrix = om.MMatrix(localMatrix) * om.MMatrix(offsetParentMatrix)\n\t\t\tlocalMTM = om.MTransformationMatrix(localMMatrix)\n\t\t\tlocalPosition = localMTM.translation(om.MSpace.kTransform)\n\t\t\tcmds.setAttr(k + '.offsetParentMatrix', om.MMatrix(), type='matrix')\n\t\t\tcmds.setAttr(k + '.translateX', localPosition.x)\n\t\t\tcmds.setAttr(k + '.translateY', localPosition.y)\n\t\t\tcmds.setAttr(k + '.translateZ', localPosition.z)\n\t\t\tcmds.setAttr(k + '.rotateX', 0)\n\t\t\tcmds.setAttr(k + '.rotateY', 0)\n\t\t\tcmds.setAttr(k + '.rotateZ', 0)\n\t\t\tcmds.setAttr(k + '.jointOrientX', om.MAngle(localMTM.rotation().x).asDegrees())\n\t\t\tcmds.setAttr(k + '.jointOrientY', om.MAngle(localMTM.rotation().y).asDegrees())\n\t\t\tcmds.setAttr(k + '.jointOrientZ', om.MAngle(localMTM.rotation().z).asDegrees())\n" )
        -mip 3
        -mi "3-Point Rotation Alignment (Top)" ( "# CMDS Method\nimport maya.cmds as cmds\nimport maya.api.OpenMaya as om\nxForms = ['joint','transform']\n\nsel = cmds.ls(absoluteName=True, orderedSelection=True, type=xForms)\nTarget = sel[0]\nP2 = sel[1]\nP1 = cmds.listRelatives(P2, parent=True, path=True, type=xForms)[0]\nP0 = cmds.listRelatives(P1, parent=True, path=True, type=xForms)[0]\n\n# Preserve Children - Store\n_children = cmds.listRelatives(Target, children=True, path=True, type=xForms)\nif _children == None:\n\t_children = []\n_childrenTMs = []\nfor i in range( len(_children) ):\n\t_childrenTMs.append( cmds.xform(_children[i], matrix=True, query=True, worldSpace=True) )\n\n# Get transforms\nP0TM = cmds.xform(P0, matrix=True, query=True, worldSpace=True)\nP0Pos = om.MVector(P0TM[12], P0TM[13], P0TM[14])\nP1TM = cmds.xform(P1, matrix=True, query=True, worldSpace=True)\nP1Pos = om.MVector(P1TM[12], P1TM[13], P1TM[14])\nP2TM = cmds.xform(P2, matrix=True, query=True, worldSpace=True)\nP2Pos = om.MVector(P2TM[12], P2TM[13], P2TM[14])\n\n# Do cross product matrix compose\nDir1 = P1Pos - P0Pos\nDir1.normalize()\nDir2 = P2Pos - P0Pos\nDir2.normalize()\nDir3 = P2Pos - P1Pos\nDir3.normalize()\nN = Dir2^Dir1\nN.normalize()\nBackDir = N^Dir1\nBackDir.normalize()\nSolutionPlaneTM = [ Dir1.x,Dir1.y,Dir1.z,0.0, BackDir.x,BackDir.y,BackDir.z,0.0, N.x,N.y,N.z,0.0, P0TM[12],P0TM[13],P0TM[14],P0TM[15] ]\n\n# Check if negative X and mirror.\nif P1TM[12] < 0:\n\tmirrorMatrix = [-1,-1,-1,1,  -1,-1,-1,1,  1,1,1,1,  1,1,1,1]\n\tfor j in range(16):\n\t\tSolutionPlaneTM[j] *= mirrorMatrix[j]\ncmds.xform(Target, matrix=SolutionPlaneTM, worldSpace=True)\n\n# Preserve Children - Restore\nfor i in range( len(_children) ):\n\tcmds.xform(_children[i], matrix=_childrenTMs[i], worldSpace=True)\ncmds.select(Target)\n" )
        -mip 4
        -mi "3-Point Rotation Alignment (Middle)" ( "# CMDS Method\nimport maya.cmds as cmds\nimport maya.api.OpenMaya as om\nxForms = ['joint','transform']\n\nsel = cmds.ls(absoluteName=True, orderedSelection=True, type=xForms)\nTarget = sel[0]\nP2 = sel[1]\nP1 = cmds.listRelatives(P2, parent=True, path=True, type=xForms)[0]\nP0 = cmds.listRelatives(P1, parent=True, path=True, type=xForms)[0]\n\n# Preserve Children - Store\n_children = cmds.listRelatives(Target, children=True, path=True, type=xForms)\nif _children == None:\n\t_children = []\n_childrenTMs = []\nfor i in range( len(_children) ):\n\t_childrenTMs.append( cmds.xform(_children[i], matrix=True, query=True, worldSpace=True) )\n\n# Get transforms\nP0TM = cmds.xform(P0, matrix=True, query=True, worldSpace=True)\nP0Pos = om.MVector(P0TM[12], P0TM[13], P0TM[14])\nP1TM = cmds.xform(P1, matrix=True, query=True, worldSpace=True)\nP1Pos = om.MVector(P1TM[12], P1TM[13], P1TM[14])\nP2TM = cmds.xform(P2, matrix=True, query=True, worldSpace=True)\nP2Pos = om.MVector(P2TM[12], P2TM[13], P2TM[14])\n\n# Do cross product matrix compose\nDir1 = P1Pos - P0Pos\nDir1.normalize()\nDir2 = P2Pos - P0Pos\nDir2.normalize()\nDir3 = P2Pos - P1Pos\nDir3.normalize()\nN = Dir2^Dir1\nN.normalize()\nBackDir = N^Dir3\nBackDir.normalize()\nSolutionPlaneTM = [ Dir3.x,Dir3.y,Dir3.z,0.0, BackDir.x,BackDir.y,BackDir.z,0.0, N.x,N.y,N.z,0.0, P1TM[12],P1TM[13],P1TM[14],P1TM[15] ]\n\n# Check if negative X and mirror.\nif P1TM[12] < 0:\n\tmirrorMatrix = [-1,-1,-1,1,  -1,-1,-1,1,  1,1,1,1,  1,1,1,1]\n\tfor j in range(16):\n\t\tSolutionPlaneTM[j] *= mirrorMatrix[j]\ncmds.xform(Target, matrix=SolutionPlaneTM, worldSpace=True)\n\n# Preserve Children - Restore\nfor i in range( len(_children) ):\n\tcmds.xform(_children[i], matrix=_childrenTMs[i], worldSpace=True)\ncmds.select(Target)" )
        -mip 5
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Shapes" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "AddShape" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "+Shape" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "baconstripShine_shelf.png" 
        -image1 "baconstripShine_shelf.png" 
        -style "iconOnly" 
        -marginWidth 0
        -marginHeight 1
        -sourceType "mel" 
        -doubleClickCommand "import pymel.core as pm\nimport maya.cmds as cmds\njointNodes = pm.ls(type='joint', sl=True)\nif cmds.pluginInfo('baconShapeBone', query=True, loaded=True) == False:\n\tcmds.loadPlugin('baconShapeBone')\nfor k in jointNodes:\n\tboneLength = 1.0\n\taverageChildPosition = [0,0,0]\n\tchildNodes = pm.listRelatives(k, c=True, s=False, ni=True, typ=['transform', 'joint'])\n\tfor c in childNodes:\n\t\taverageChildPosition += c.getTranslation(space='object')\n\tnumChilds = len(childNodes)\n\tif numChilds > 0:\n\t    averageChildPosition /= numChilds\n\t    boneLength = averageChildPosition.length()\n\tnextBone = pm.createNode('baconShapeBone', parent=k)\n\tpm.rename(nextBone, k.shortName() + \"_Shape\")\n\tnextBone.setAttr('shapeSizeX', boneLength)\n\tfractionLength = boneLength / 5\n\tnextBone.setAttr('shapeSizeY', fractionLength)\n\tnextBone.setAttr('shapeSizeZ', fractionLength)\npm.select(jointNodes)" 
        -commandRepeatable 1
        -flat 1
        -mi "Add Bacon Shape Bone (selection) [BSPLUG]" ( "import maya.cmds as cmds\nimport maya.api.OpenMaya as om\nxForms = ['joint','transform']\n\nif cmds.pluginInfo('baconShapeBone', query=True, loaded=True) == False:\n\tcmds.loadPlugin('baconShapeBone')\n\nsel = cmds.ls(absoluteName=True, orderedSelection=True, type=xForms)\nfor k in sel:\n\tshapeName = cmds.ls(k)[0] + '_Shape'\n\tif cmds.objectType(k) == 'joint':\n\t\tboneLength = 0.0\n\t\tisMirror = False\n\t\tchildNodes = cmds.listRelatives(k, children=True, path=True, type=xForms)\n\t\tif len(childNodes) > 0:\n\t\t\tfor c in childNodes:\n\t\t\t\tnextPos = om.MVector(cmds.xform(c, os=True, t=True, query=True))\n\t\t\t\tnextDistance = nextPos.length() #* (nextPos.x/abs(nextPos.x)) #get sign quickly\n\t\t\t\tif abs(nextDistance) > abs(boneLength):\n\t\t\t\t\t boneLength = nextDistance\n\t\t\t\t\t if (nextPos.x/abs(nextPos.x)) < 0:\n\t\t\t\t\t \tisMirror = True\n\t\telse:\n\t\t\tboneLength = 1.0\n\t\tnextBone = cmds.createNode('baconShapeBone', parent=k, n=shapeName)\n\t\tcmds.color( nextBone, ud=2 )\n\t\tcmds.setAttr(nextBone+'.shapeSizeX', boneLength)\n\t\tfractionLength = boneLength / 5\n\t\tcmds.setAttr(nextBone+'.shapeSizeY', fractionLength)\n\t\tcmds.setAttr(nextBone+'.shapeSizeZ', fractionLength)\n\t\tcmds.setAttr(nextBone+'.xRay', 1)\n\t\tcmds.setAttr(nextBone+'.mirror', isMirror)\n\t\tcmds.setAttr(k+'.drawStyle', 2)\n\telse:\n\t\tnextBone = cmds.createNode('baconShapeBone', parent=k, n=shapeName)\n\t\tcmds.setAttr(nextBone+'.shapeType', 7)\n\t\tcmds.setAttr(nextBone+'.xRay', 1)\ncmds.select(sel)\t\n\t\nnode = cmds.ls(absoluteName=True, orderedSelection=True, type=xForms)[0]\t\n" )
        -mip 0
        -mi "Add Bacon Shape Line (slolam) [BSPLUG]" ( "import maya.cmds as cmds\nimport maya.api.OpenMaya as om\nxForms = ['joint','transform']\n\nif cmds.pluginInfo('baconShapeLine', query=True, loaded=True) == False:\n\tcmds.loadPlugin('baconShapeLine')\n\nsel = cmds.ls(absoluteName=True, orderedSelection=True, type=xForms)\nnodesWithShape = []\nfor i in range(0, len(sel), 2):\n\tif (i + 1) <= len(sel):\n\t\tshapeName = cmds.ls(sel[i])[0] + '_LineShape'\n\t\tnextShape = cmds.createNode('baconShapeLine', parent=sel[i], n=shapeName)\n\t\tcmds.setAttr(nextShape+'.lineType', 0) #wireColor0\n\t\tcmds.setAttr(nextShape+'.wireIntensity', 0.2)\n\t\tcmds.connectAttr(sel[i]+'.worldMatrix', nextShape+'.parentTM', f=True)\n\t\tcmds.connectAttr(sel[i+1]+'.worldMatrix', nextShape+'.targetMatrix', f=True)\n\t\tnodesWithShape.append(sel[i])\ncmds.select(nodesWithShape)" )
        -mip 1
        -mi "Remove Bacon Shape Bone (selection) [BSPLUG]" ( "# Remove BaconShapeBones\nimport maya.cmds as cmds\nif cmds.pluginInfo('baconShapeBone', query=True, loaded=True) == False:\n\tcmds.loadPlugin('baconShapeBone')\nsel = cmds.ls(absoluteName=True, orderedSelection=True, type=xForms)\nfor k in sel:\n\tkShapes = cmds.listRelatives(k, children=True, path=True, type='baconShapeBone')\n\tprint(kShapes)\n\tif kShapes != None:\n\t\tcmds.delete(kShapes)\n\t\tif cmds.objectType(k) == 'joint':\n\t\t\tcmds.setAttr(k+'.drawStyle', 0)" )
        -mip 2
        -mi "Remove Bacon Shape Line (selection) [BSPLUG]" ( "import maya.cmds as cmds\nif cmds.pluginInfo('baconShapeLine', query=True, loaded=True) == False:\n\tcmds.loadPlugin('baconShapeLine')\nsel = cmds.ls(absoluteName=True, orderedSelection=True, type=xForms)\nfor k in sel:\n\tkShapes = cmds.listRelatives(k, children=True, path=True, type='baconShapeLine')\n\tprint(kShapes)\n\tif kShapes != None:\n\t\tcmds.delete(kShapes)\n" )
        -mip 3
        -mi "Transfer Shapes (slolam)" ( "import maya.cmds as cmds\nimport maya.api.OpenMaya as om\nxForms = ['joint','transform']\n\nsel = cmds.ls(absoluteName=True, orderedSelection=True, type=xForms)\nfinalSel = []\nfor i in range(0, len(sel), 2):\n\tif (i + 1) <= len(sel):\n\t\tfinalSel.append(sel[i+1])\n\t\tshapes = cmds.listRelatives(sel[i], shapes=True, path=True)\n\t\tfor s in shapes:\n\t\t\tif cmds.objectType(s) == 'mesh':\n\t\t\t\tvertPositions = []\n\t\t\t\tnumOfVerts = cmds.polyEvaluate(s, vertex=True)\n\t\t\t\tfor v in range(numOfVerts):\n\t\t\t\t\tvertPositions.append( cmds.xform(s+'.vtx['+ v.__str__() + ']', q=True, translation=True, worldSpace=True) )\n\t\t\t\tcmds.parent(s, sel[i+1], shape=True, relative=True )\n\t\t\t\tfor v in range(numOfVerts):\n\t\t\t\t\tcmds.xform(s+'.vtx['+ v.__str__() + ']', translation=vertPositions[v], worldSpace=True)\n\t\t\telif cmds.objectType(s) == 'nurbsCurve':\n\t\t\t\tcvPositions = []\n\t\t\t\tnumberOfCVs = len(cmds.getAttr( s+'.cv[*]' )) #cmds.getAttr( s+'.spans' )\n\t\t\t\tfor cv in range(numberOfCVs):\n\t\t\t\t\tcvPositions.append ( cmds.xform(s+'.cv['+ cv.__str__() + ']', q=True, translation=True, worldSpace=True) )\n\t\t\t\tcmds.parent( s, sel[i+1], shape=True, relative=True )\n\t\t\t\tfor cv in range(numberOfCVs):\n\t\t\t\t\tcmds.xform(s+'.cv['+ cv.__str__() + ']', translation=cvPositions[cv], worldSpace=True)\n\t\t\telse:\n\t\t\t\tcmds.parent( s, sel[i+1], shape=True, relative=True )\n\ncmds.select(finalSel)\t" )
        -mip 4
        -mi "Parent Shape (relative)" ( "import maya.cmds as cmds\nimport maya.api.OpenMaya as om\nxForms = ['joint','transform']\n\nNodes = cmds.ls(absoluteName=True, orderedSelection=True)\ncmds.parent(Nodes[0], Nodes[1], shape=True, relative=True )" )
        -mip 5
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Duplicate Simple with no children" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Duplicate" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "Dup" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "baconstrip_shelf_2.png" 
        -image1 "baconstrip_shelf_2.png" 
        -style "iconOnly" 
        -marginWidth 0
        -marginHeight 1
        -command "import maya.cmds as cmds\nimport maya.api.OpenMaya as om\nxForms = ['joint','transform']\n\nsel = cmds.ls(absoluteName=True, orderedSelection=True, type=xForms)\nfor k in sel:\n\tdup = cmds.duplicate(k, fullPath=True)\n\tchildren = cmds.listRelatives(dup, children=True, path=True, type=xForms)\n\tcmds.delete(children) #this method is better than parentOnly=True since shapes were not being copied.\n\n" 
        -sourceType "python" 
        -commandRepeatable 1
        -flat 1
        -mi "Duplicate (no Children)" ( "# Duplicate (no Children)\nimport maya.cmds as cmds\nimport maya.api.OpenMaya as om\nxForms = ['joint','transform']\nsel = cmds.ls(absoluteName=True, orderedSelection=True ) #type=xForms\nfor k in sel:\n\tdup = cmds.duplicate(k, fullPath=True)\n\tchildren = cmds.listRelatives(dup, children=True, path=True, type=xForms)\n\tcmds.delete(children) #this method is better than parentOnly=True since shapes were not being copied." )
        -mip 0
        -mi "Duplicate (+Connections) (no Children)" ( "# Duplicate (+Connections) (no Children)\nimport maya.cmds as cmds\nimport maya.api.OpenMaya as om\nxForms = ['joint','transform']\nsel = cmds.ls(absoluteName=True, orderedSelection=True ) #type=xForms\nfor k in sel:\n\tdup = cmds.duplicate(k, fullPath=True, inputConnections=True)\n\tchildren = cmds.listRelatives(dup, children=True, path=True, type=xForms)\n\tcmds.delete(children) #this method is better than parentOnly=True since shapes were not being copied." )
        -mip 1
        -mi "Duplicate (+Connections) (with Children)" ( "# Duplicate (+Connections) (with Children)\nimport maya.cmds as cmds\nimport maya.api.OpenMaya as om\nxForms = ['joint','transform']\nsel = cmds.ls(absoluteName=True, orderedSelection=True ) #type=xForms\nfor k in sel:\n\tdup = cmds.duplicate(k, fullPath=True, inputConnections=True)" )
        -mip 2
        -mi "Duplicate and Mirror Curve Spline" ( "import maya.cmds as cmds\nimport maya.api.OpenMaya as om\nxForms = ['joint','transform']\n\nsel = cmds.ls(absoluteName=True, orderedSelection=True, type=xForms)\nfor k in sel:\n\tkShape = cmds.listRelatives(k, shapes=True, fullPath=True)[0]\n\tkDup = (cmds.duplicate(k, fullPath=True))[0]\n\tchildren = cmds.listRelatives(kDup, children=True, path=True, type=xForms)\n\tif children != None:\n\t\tcmds.delete(children) #this method is better than parentOnly=True since shapes were not being copied.\n\tkDupShape = (cmds.listRelatives(kDup, shapes=True, fullPath=True))[0]\n\tnumberOfCVs = len(cmds.getAttr( kShape+'.cv[*]' )) #cmds.getAttr( kShape+'.spans' )\n\tfor cv in range(numberOfCVs):\n\t\tvertPos = cmds.xform(kDupShape+'.cv['+ cv.__str__() + ']', q=True, translation=True, worldSpace=True)\n\t\tvertPos[0] *= -1.0\n\t\tcmds.xform(kDupShape+'.cv['+ cv.__str__() + ']', translation=vertPos, worldSpace=True)\n" )
        -mip 3
        -mi "Duplicate and Mirror Hierarchy (selection)" ( "import maya.cmds as cmds\nimport maya.api.OpenMaya as om\n\ndef replaceSuffix(name, delimiter='_', search='l', replace='r'):\n\tsplit = name.rsplit(delimiter, 1) or name\n\tnewName = name\n\tif len(split) > 1:\n\t\tif split[1] == search:\n\t\t\tnewName = split[0] + delimiter + replace\n\t\telif split[1] == replace:\n\t\t\tnewName = split[0] + delimiter + search\n\treturn(newName)\n\ndef mirrorX(tm):\n\t\tflipMatrix = [1,-1,-1,1,  1,-1,-1,1,  1,-1,-1,1,  -1,1,1,1]\n\t\tfor j in range(16):\n\t\t\ttm[j] *= flipMatrix[j]\n\t\treturn(tm)\n\ndef freezeJoint(k):\n\tif cmds.objectType(k) == 'joint':\n\t\toffsetParentMatrix = cmds.getAttr(k + '.offsetParentMatrix')\n\t\tlocalMatrix = cmds.xform(k, matrix=True, objectSpace=True, query=True)\n\t\tlocalMMatrix = om.MMatrix(localMatrix) * om.MMatrix(offsetParentMatrix)\n\t\tlocalMTM = om.MTransformationMatrix(localMMatrix)\n\t\tlocalPosition = localMTM.translation(om.MSpace.kTransform)\n\t\tcmds.setAttr(k + '.offsetParentMatrix', om.MMatrix(), type='matrix')\n\t\tcmds.setAttr(k + '.translateX', localPosition.x)\n\t\tcmds.setAttr(k + '.translateY', localPosition.y)\n\t\tcmds.setAttr(k + '.translateZ', localPosition.z)\n\t\tcmds.setAttr(k + '.rotateX', 0)\n\t\tcmds.setAttr(k + '.rotateY', 0)\n\t\tcmds.setAttr(k + '.rotateZ', 0)\n\t\tcmds.setAttr(k + '.jointOrientX', om.MAngle(localMTM.rotation().x).asDegrees())\n\t\tcmds.setAttr(k + '.jointOrientY', om.MAngle(localMTM.rotation().y).asDegrees())\n\t\tcmds.setAttr(k + '.jointOrientZ', om.MAngle(localMTM.rotation().z).asDegrees())\n\nsel = cmds.ls(absoluteName=True, orderedSelection=True, type=xForms)\nfor SourceRootNode in sel:\n\tMirrorRootName = replaceSuffix( cmds.ls(SourceRootNode)[0], delimiter='_', search='l', replace='r')\n\tMirrorRootNode = (cmds.duplicate(SourceRootNode, name=MirrorRootName))[0]\n\tMirrorHierarchy = [MirrorRootNode]\n\tMirrorNames = [MirrorRootName]\n\tMirrorTM = [cmds.xform(MirrorRootNode, matrix=True, query=True, worldSpace=True)]\n\t# Get hierarchy information\n\tfor k in MirrorHierarchy:\n\t\tchildren = cmds.listRelatives(k, children=True, path=True, type=xForms)\n\t\tif children != None:\n\t\t\tfor c in children:\n\t\t\t\tMirrorHierarchy.append(c)\n\t\t\t\tMirrorTM.append(cmds.xform(c, matrix=True, query=True, worldSpace=True))\n\t\t\t\tMirrorNames.append(replaceSuffix( cmds.ls(c)[0].rsplit('|')[-1], delimiter='_', search='l', replace='r'))\n\t# Mirror Hierarchy and shapes.\n\tfor i in range(len(MirrorHierarchy)):\n\t\tcmds.xform( MirrorHierarchy[i], matrix=(mirrorX(MirrorTM[i])), worldSpace=True )\n\t\tfreezeJoint(MirrorHierarchy[i])\n\t\tboneShapes = cmds.listRelatives(MirrorHierarchy[i], shapes=True, path=True)\n\t\tif boneShapes != None:\n\t\t\tfor s in boneShapes:\n\t\t\t\tif cmds.objectType(s) == 'baconShapeBone':\n\t\t\t\t\tcmds.setAttr(s+'.mirror', True)\n\t# Change the names in a way that works with this maya.cmds trash method and \n\t# doesn't break the stored names. Gee, wouldn't it be great to have object pointers.\n\tfor i in range(len(MirrorHierarchy)-1, -1, -1):\n\t\tif i > 0:\n\t\t\tprint(MirrorNames[i])\n\t\t\tcmds.rename(MirrorHierarchy[i], MirrorNames[i])\n\n\n" )
        -mip 4
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Bacon-Strip constraints and quick rigs." 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Constraints" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "Cons" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "baconConstraints2.png" 
        -image1 "baconConstraints2.png" 
        -style "iconOnly" 
        -marginWidth 0
        -marginHeight 1
        -command "print(\"User defined macro\");" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
        -mi "Remove Construction Nodes" ( "import maya.cmds as cmds\nimport maya.api.OpenMaya as om\nxForms = ['joint','transform']\nif cmds.pluginInfo('baconShapeBone', query=True, loaded=True) == False:\n\tcmds.loadPlugin('baconShapeBone')\n\nAllJoints = cmds.ls(absoluteName=True, type='joint')\nAllConstructionNodes = []\nfor k in AllJoints:\n\tsourceCons = cmds.listConnections(k+'.offsetParentMatrix', destination=False, source=True, plugs=True, exactType=True)\n\tif sourceCons != None:\n\t\tprint(sourceCons)\n\t\tfor scon in sourceCons:\n\t\t\tcmds.disconnectAttr(scon, k+'.offsetParentMatrix') \n\tkShapes = cmds.listRelatives(k, shapes=True, path=True)\n\tif kShapes != None:\n\t\tfor s in cmds.listRelatives(k, shapes=True, path=True):\n\t\t\tif cmds.objectType(s) == 'baconShapeBone':\n\t\t\t\tif cmds.getAttr(s+'.boneType') == 2:\n\t\t\t\t\tAllConstructionNodes.append(k)\ncmds.delete(AllConstructionNodes)\n\n" )
        -mip 0
        -mi "Bacon Roll Bones [BSPLUG]" ( "import maya.cmds as cmds\nimport maya.api.OpenMaya as om\nxForms = ['joint','transform']\nif cmds.pluginInfo('baconRoll', query=True, loaded=True) == False:\n\tcmds.loadPlugin('baconRoll')\n\nsel = cmds.ls(absoluteName=True, orderedSelection=True, type=xForms)\nselCount = len(sel)\nif selCount >= 2 and selCount <= 5:\n\ttarget = sel[0]\n\troll1 = sel[1]\n\tbaconRoll = cmds.createNode('baconRoll', n=('baconRoll_' + cmds.ls(roll1)[0]))\t\n\tcmds.connectAttr(target+'.parentMatrix', baconRoll+'.targetParentMatrix', f=True)\n\tcmds.connectAttr(roll1+'.parentMatrix', baconRoll+'.parentMatrix', f=True)\n\troll1Parent = cmds.listRelatives(roll1, parent=True, path=True, type=xForms)[0]\n\tif target != roll1Parent:\n\t\tcmds.connectAttr(target+'.rotate', baconRoll+'.targetRotation', f=True)\n\tfor i in range(1, selCount):\n\t\tcmds.connectAttr(baconRoll+'.rollRotation'+ i.__str__(), sel[i]+'.rotateX', f=True)\n" )
        -mip 1
        -mi "Reverse Foot [BSPLUG]" ( "import maya.cmds as cmds\nimport maya.api.OpenMaya as om\nimport math, sys\nxForms = ['joint','transform']\n\npluginsToLoad = ['baconShapeBone', 'baconAlign', 'baconMatrixCompose']\nfor plugs in pluginsToLoad:\n\tif cmds.pluginInfo(plugs, query=True, loaded=True) == False:\n\t\tcmds.loadPlugin(plugs)\n\n#------------------------------------------------------------------------------------------------------------------------------------------------------------\n#------------------------------------------------------------------------------------------------------------------------------------------------------------\n# Functions\n\ndef getRootNode(node):\n\tGramps = None\n\tPops = node\n\twhile Gramps == None:\n\t\tnextPops = cmds.listRelatives(Pops, parent=True, path=True, type=xForms)\n\t\tif nextPops == None:\n\t\t\tGramps = Pops\n\t\telse:\n\t\t\tPops = nextPops[0]\n\treturn(Gramps)\n\t\ndef getHierarchyLevel(node):\n\tGramps = None\n\tPops = node\n\tLevel = 0\n\twhile Gramps == None:\n\t\tnextPops = cmds.listRelatives(Pops, parent=True, path=True, type=xForms)\n\t\tif nextPops == None:\n\t\t\tGramps = Pops\n\t\telse:\n\t\t\tPops = nextPops[0]\n\t\t\tLevel += 1\n\treturn(Level)\t\n\ndef createBaconLocator( name='locator' ):\n\ttry:\n\t\tnewJoint = cmds.createNode('joint', n=name)\n\t\tcmds.setAttr(newJoint + '.drawStyle', 2)\n\t\tshapeName = cmds.ls(newJoint, shortNames=True)[0] + '_Shape'\n\t\tboneShape = cmds.createNode('baconShapeBone', parent=newJoint, n=shapeName)\n\t\tcmds.setAttr(boneShape + '.shapeType', 7)\n\t\tcmds.setAttr(boneShape + '.xRay', 0)\n\t\treturn(newJoint)\n\texcept AttributeError:\n\t\tprint('Error creating BaconLocator.')\n\texcept RuntimeError:\n\t\tprint('Runtime Error.')\n\ndef createBaconLine(nodeStart, nodeEnd):\n\tshapeName = cmds.ls(nodeStart)[0] + '_LineShape'\n\tnextShape = cmds.createNode('baconShapeLine', parent=nodeStart, n=shapeName)\n\tcmds.setAttr(nextShape+'.lineType', 0) #wireColor0\n\tcmds.setAttr(nextShape+'.wireIntensity', 0.2)\n\tcmds.connectAttr(nodeStart+'.worldMatrix', nextShape+'.parentTM', f=True)\n\tcmds.connectAttr(nodeEnd+'.worldMatrix', nextShape+'.targetMatrix', f=True)\n\ndef ZeroByJointOrient(k):\n\tif cmds.objectType(k) == 'joint':\n\t\toffsetParentMatrix = cmds.getAttr(k + '.offsetParentMatrix')\n\t\tlocalMatrix = cmds.xform(k, matrix=True, objectSpace=True, query=True)\n\t\tlocalMMatrix = om.MMatrix(localMatrix) * om.MMatrix(offsetParentMatrix)\n\t\tlocalMTM = om.MTransformationMatrix(localMMatrix)\n\t\tlocalPosition = localMTM.translation(om.MSpace.kTransform)\n\t\tcmds.setAttr(k + '.offsetParentMatrix', om.MMatrix(), type='matrix')\n\t\tcmds.setAttr(k + '.translateX', localPosition.x)\n\t\tcmds.setAttr(k + '.translateY', localPosition.y)\n\t\tcmds.setAttr(k + '.translateZ', localPosition.z)\n\t\tcmds.setAttr(k + '.rotateX', 0)\n\t\tcmds.setAttr(k + '.rotateY', 0)\n\t\tcmds.setAttr(k + '.rotateZ', 0)\n\t\tcmds.setAttr(k + '.jointOrientX', om.MAngle(localMTM.rotation().x).asDegrees())\n\t\tcmds.setAttr(k + '.jointOrientY', om.MAngle(localMTM.rotation().y).asDegrees())\n\t\tcmds.setAttr(k + '.jointOrientZ', om.MAngle(localMTM.rotation().z).asDegrees())\n\ndef ZeroByOffsetParentMatrix(k):\n\toffsetParentMatrix = cmds.getAttr(k + '.offsetParentMatrix')\n\tlocalMatrix = cmds.xform(k, matrix=True, objectSpace=True, query=True)\n\tlocalMMatrix = om.MMatrix(localMatrix) * om.MMatrix(offsetParentMatrix)\n\tcmds.setAttr(k + '.offsetParentMatrix', localMMatrix, type='matrix')\n\tcmds.setAttr(k + '.translateX', 0)\n\tcmds.setAttr(k + '.translateY', 0)\n\tcmds.setAttr(k + '.translateZ', 0)\n\tcmds.setAttr(k + '.rotateX', 0)\n\tcmds.setAttr(k + '.rotateY', 0)\n\tcmds.setAttr(k + '.rotateZ', 0)\n\tif cmds.objectType(k) == 'joint':\n\t\tcmds.setAttr(k + '.jointOrientX', 0)\n\t\tcmds.setAttr(k + '.jointOrientY', 0)\n\t\tcmds.setAttr(k + '.jointOrientZ', 0)\n\ndef mirrorMatrixRotation(TM):\n\tmirrorMatrix = [-1,-1,-1,1,  -1,-1,-1,1,  1,1,1,1,  1,1,1,1]\n\tfor j in range(16):\n\t\tTM[j] *= mirrorMatrix[j]\n\treturn(TM)\n\n#------------------------------------------------------------------------------------------------------------------------------------------------------------\n#------------------------------------------------------------------------------------------------------------------------------------------------------------\n# AutoRig Reverse-Foot\n\n'''\nNodeToe = cmds.ls(absoluteName=True, orderedSelection=True, type=xForms)[0]\n\n'''\n\ndef autoRigReverseFoot(NodeToe):\n\t# Nodes\n\tNodeAnkle = cmds.listRelatives(NodeToe, parent=True, path=True, type=xForms)[0]\n\tNodeCalf = cmds.listRelatives(NodeAnkle, parent=True, path=True, type=xForms)[0]\n\tNodeFemur = cmds.listRelatives(NodeCalf, parent=True, path=True, type=xForms)[0]\n\tNodeRigRoot = getRootNode(NodeToe)\n\n\t# Get Foot Parameters\n\tNodeAffix = '_l'\n\tSetupColorID = 6\n\tConstructionColorID = 2\n\tBoneDirection = 1\n\tDirectionSign = -1\n\tCalfLocalPos = om.MVector(cmds.xform(NodeCalf, ws=False, t=True, query=True))\n\tif CalfLocalPos.x > 0:\n\t\tNodeAffix = '_r'\n\t\tSetupColorID = 8\n\t\tBoneDirection = 0\n\t\tDirectionSign = 1\t\t\n\tflipSign = DirectionSign + (-2 * DirectionSign)\n\n\t# Get Transforms and Positions\n\tToeTM = cmds.xform(NodeToe, matrix=True, query=True, worldSpace=True)\n\tToePos = om.MVector(cmds.xform(NodeToe, ws=True, t=True, query=True))\n\tAnkleTM = cmds.xform(NodeAnkle, matrix=True, query=True, worldSpace=True)\n\tAnklePos = om.MVector(cmds.xform(NodeAnkle, ws=True, t=True, query=True))\n\tCalfTM = cmds.xform(NodeCalf, matrix=True, query=True, worldSpace=True)\n\tCalfPos = om.MVector(cmds.xform(NodeCalf, ws=True, t=True, query=True))\n\tFemurTM = cmds.xform(NodeFemur, matrix=True, query=True, worldSpace=True)\n\tFemurPos = om.MVector(cmds.xform(NodeFemur, ws=True, t=True, query=True))\n\n\t# Get relative foot length for visual scaling\n\tFootDirection = ToePos - AnklePos\n\tFootLength = (ToePos - AnklePos).length()\n\n\t# c_foot_root\n\tNodeFootControlsRoot = createBaconLocator( name='c_foot_root'+NodeAffix )\n\tcmds.color(NodeFootControlsRoot, ud=SetupColorID)\n\tcmds.setAttr(NodeFootControlsRoot+'.boneType', 1)\n\tcmds.setAttr(NodeFootControlsRoot+'.wireThickness', 2)\n\tcmds.setAttr(NodeFootControlsRoot+'.shapeSizeX', FootLength * 0.25 ) \n\tcmds.setAttr(NodeFootControlsRoot+'.shapeSizeY', FootLength * 0.25 )\n\tcmds.setAttr(NodeFootControlsRoot+'.shapeSizeZ', FootLength * 0.25 )\n\tcFootRoot_X = om.MVector(FootDirection.x,0,FootDirection.z).normal() * DirectionSign\n\tcFootRoot_Z = (cFootRoot_X ^ om.MVector(0,DirectionSign,0)).normal()\n\tcFootRoot_TM = [cFootRoot_X.x, cFootRoot_X.y, cFootRoot_X.z, 0,  0,DirectionSign,0,0, \\\n\t\tcFootRoot_Z.x, cFootRoot_Z.y, cFootRoot_Z.z, 0, ToeTM[12], ToeTM[13], ToeTM[14], 1.0 ]\n\tcmds.xform(NodeFootControlsRoot, matrix=cFootRoot_TM, worldSpace=True)\n\n\t#LowerControl\n\tNodeFootLowerControl = createBaconLocator( name='c_foot_lower'+NodeAffix )\n\tcmds.color(NodeFootLowerControl, ud=SetupColorID)\n\tcmds.setAttr(NodeFootLowerControl+'.boneType', 1)\n\tcmds.setAttr(NodeFootLowerControl+'.shapeType', 0)\n\tcmds.setAttr(NodeFootLowerControl+'.mirror', BoneDirection)\n\tcmds.setAttr(NodeFootLowerControl+'.shapeSizeX', FootLength * .5 ) #*ForwardDirection\n\tcmds.setAttr(NodeFootLowerControl+'.shapeSizeY', FootLength * 0.1)\n\tcmds.setAttr(NodeFootLowerControl+'.shapeSizeZ', FootLength * 0.5)\n\tcmds.setAttr(NodeFootLowerControl+'.shapeOffsetY', FootLength * 0.3)\n\tcmds.setAttr(NodeFootLowerControl+'.shapeOffsetX', FootLength * 0.15 )\n\tcmds.xform(NodeFootLowerControl, matrix=cFootRoot_TM, worldSpace=True)\n\n\t#UpperControl\n\tNodeFootUpperControl = createBaconLocator( name='c_foot_upper'+NodeAffix )\n\tcmds.color(NodeFootUpperControl, ud=SetupColorID)\n\tcmds.setAttr(NodeFootUpperControl+'.boneType', 1)\n\tcmds.setAttr(NodeFootUpperControl+'.shapeType', 0)\n\tcmds.setAttr(NodeFootUpperControl+'.mirror', BoneDirection)\n\tcmds.setAttr(NodeFootUpperControl+'.shapeSizeX', FootLength * -1) #*ForwardDirection\n\tcmds.setAttr(NodeFootUpperControl+'.shapeSizeY', FootLength * 0.1)\n\tcmds.setAttr(NodeFootUpperControl+'.shapeSizeZ', FootLength * 0.5)\n\tcmds.setAttr(NodeFootUpperControl+'.shapeOffsetY', FootLength * 0.3)\n\tcFootUpper_X = FootDirection.normal() * DirectionSign\n\tcFootUpper_Z = (cFootUpper_X ^ om.MVector(0,DirectionSign,0)).normal()\n\tcFootUpper_Y = (cFootUpper_Z ^ cFootUpper_X).normal()\n\tcFootUpper_TM = [cFootUpper_X.x, cFootUpper_X.y, cFootUpper_X.z, 0,  cFootUpper_Y.x, cFootUpper_Y.y, cFootUpper_Y.z, 0, \\\n\t\tcFootUpper_Z.x, cFootUpper_Z.y, cFootUpper_Z.z, 0, ToeTM[12], ToeTM[13], ToeTM[14], 1.0 ]\n\tcmds.xform(NodeFootUpperControl, matrix=cFootUpper_TM, worldSpace=True)\n\n\t#ToeLiftControl\n\tNodeToeLift = createBaconLocator( name='c_foot_toe_lift'+NodeAffix )\n\tcmds.color(NodeToeLift, ud=SetupColorID)\n\tcmds.setAttr(NodeToeLift+'.boneType', 1)\n\tcmds.setAttr(NodeToeLift+'.shapeType', 0)\n\tcmds.setAttr(NodeToeLift+'.mirror', BoneDirection)\n\tcmds.setAttr(NodeToeLift+'.shapeSizeX', FootLength * .4 )\n\tcmds.setAttr(NodeToeLift+'.shapeSizeY', FootLength * 0.1)\n\tcmds.setAttr(NodeToeLift+'.shapeSizeZ', FootLength * 0.1)\n\tcmds.setAttr(NodeToeLift+'.shapeOrientationZ', 90.0)\n\tcFootToeLift_TM = cFootRoot_TM.copy()\n\tcFootToeLift_Pos = om.MVector(ToePos.x, 0, ToePos.z) + (FootDirection.normal() * FootLength * 0.75 )\n\tcFootToeLift_TM[12] = cFootToeLift_Pos.x\n\tcFootToeLift_TM[13] = cFootToeLift_Pos.y = 0.0\n\tcFootToeLift_TM[14] = cFootToeLift_Pos.z\n\tcmds.xform(NodeToeLift, matrix=cFootToeLift_TM, worldSpace=True)\n\n\t#Construction Heel\n\tconstructHeel = createBaconLocator( name='construction_Heel'+NodeAffix )\n\tcmds.color(constructHeel, ud=ConstructionColorID)\n\tcmds.setAttr(constructHeel+'.boneType', 2)\n\tcmds.setAttr(constructHeel+'.xRay', 1)\n\tcmds.setAttr(constructHeel+'.wireThickness', 2)\n\tcmds.setAttr(constructHeel+'.shapeType', 4)\n\tcmds.setAttr(constructHeel+'.shapeSizeX', FootLength * 0.2 )\n\tcmds.setAttr(constructHeel+'.shapeSizeY', FootLength * 0.2 )\n\tcmds.setAttr(constructHeel+'.shapeSizeZ', FootLength * 0.2 )\n\tconstructHeel_TM = cFootRoot_TM.copy()\n\tconstructHeel_Pos = om.MVector(AnklePos.x, 0, AnklePos.z) + (FootDirection.normal() * FootLength * -0.5 )\n\tconstructHeel_TM[12] = constructHeel_Pos.x\n\tconstructHeel_TM[13] = constructHeel_Pos.y = 0.0\n\tconstructHeel_TM[14] = constructHeel_Pos.z\n\tcmds.xform(constructHeel, matrix=constructHeel_TM, worldSpace=True)\n\n\t#Construction Tip\n\tconstructTip = createBaconLocator( name='construction_Tip'+NodeAffix )\n\tcmds.color(constructTip, ud=ConstructionColorID)\n\tcmds.setAttr(constructTip+'.boneType', 2)\n\tcmds.setAttr(constructTip+'.xRay', 1)\n\tcmds.setAttr(constructTip+'.wireThickness', 2)\n\tcmds.setAttr(constructTip+'.shapeType', 4)\n\tcmds.setAttr(constructTip+'.shapeSizeX', FootLength * 0.2 )\n\tcmds.setAttr(constructTip+'.shapeSizeY', FootLength * 0.2 )\n\tcmds.setAttr(constructTip+'.shapeSizeZ', FootLength * 0.2 )\n\tcmds.xform(constructTip, matrix=cFootToeLift_TM, worldSpace=True)\n\n\t#Construction Root\n\tconstructRoot = createBaconLocator( name='construction_foot_root'+NodeAffix )\n\tcmds.color(constructRoot, ud=ConstructionColorID)\n\tcmds.setAttr(constructRoot+'.xRay', 1)\n\tcmds.setAttr(constructRoot+'.boneType', 2)\n\tcmds.setAttr(constructRoot+'.wireThickness', 2)\n\tcmds.setAttr(constructRoot+'.shapeType', 4)\n\tcmds.setAttr(constructRoot+'.shapeSizeX', FootLength * 0.2 ) \n\tcmds.setAttr(constructRoot+'.shapeSizeY', FootLength * 0.2 )\n\tcmds.setAttr(constructRoot+'.shapeSizeZ', FootLength * 0.2 )\n\tcmds.xform(constructRoot, matrix=cFootRoot_TM, worldSpace=True)\n\n\t#FootControl\n\tNodeFootControl = createBaconLocator( name='c_foot'+NodeAffix )\n\tcFootDirection = cFootToeLift_Pos - constructHeel_Pos\n\tcmds.color(NodeFootControl, ud=SetupColorID)\n\tcmds.setAttr(NodeFootControl+'.boneType', 1)\n\tcmds.setAttr(NodeFootControl+'.shapeType', 0)\n\tcmds.setAttr(NodeFootControl+'.mirror', BoneDirection)\n\tcmds.setAttr(NodeFootControl+'.shapeSizeX', cFootDirection.length())\n\tcmds.setAttr(NodeFootControl+'.shapeSizeY', FootLength * 0.05)\n\tcmds.setAttr(NodeFootControl+'.shapeSizeZ', FootLength * 0.75)\n\n\t# IK handle\n\tNodeIKHandle, NodeIKEffector = cmds.ikHandle( sj=NodeFemur, ee=NodeAnkle, n=('IKHandle_foot'+NodeAffix) )\n\n\t# 3-Point Alignment Calculation\n\tDir1 = CalfPos - FemurPos\n\tDir1.normalize()\n\tDir2 = AnklePos - FemurPos\n\tLegLength = Dir2.length()\n\tDir2.normalize()\n\tDir3 = AnklePos - CalfPos\n\tDir3.normalize()\n\tN = Dir2^Dir1\n\tN.normalize()\n\tBackDir = N^Dir3\n\tBackDir.normalize()\n\n\tUpTM = [ Dir3[0],Dir3[1],Dir3[2],0.0,    BackDir[0],BackDir[1],BackDir[2],0.0, \\\n\t\tN[0],N[1],N[2],0.0,   CalfTM[12], CalfTM[13], CalfTM[14], CalfTM[15] ]\n\n\tif BoneDirection == 1:\n\t\tUpTM = mirrorMatrixRotation(UpTM)\n\n\t# IK PoleVector\n\tNodeUp = createBaconLocator( name='c_leg_up'+NodeAffix )\n\tcmds.color(NodeUp, ud=SetupColorID)\n\tcmds.setAttr(NodeUp+'.shapeType', 4)\n\tcmds.setAttr(NodeUp+'.boneType', 1)\n\tcmds.setAttr(NodeUp+'.shapeSizeX', FootLength * 0.25 )\n\tcmds.setAttr(NodeUp+'.shapeSizeY', FootLength * 0.25 )\n\tcmds.setAttr(NodeUp+'.shapeSizeZ', FootLength * 0.25 )\n\tcmds.xform(NodeUp, matrix=UpTM, worldSpace=True)\n\tcmds.xform(NodeUp, translation=(0,LegLength*0.75*DirectionSign,0), relative=True, objectSpace=True)\n\tcreateBaconLine(NodeUp, NodeCalf)\n\tcmds.poleVectorConstraint(NodeUp, NodeIKHandle)\n\n\t#------------------------------------------------------------------------------\n\t# Parenting\n\tcmds.parent(NodeFootControl, NodeRigRoot)\n\tcmds.parent(constructHeel, NodeRigRoot)\n\tcmds.parent(constructTip, NodeRigRoot)\n\tcmds.parent(constructRoot, NodeRigRoot)\n\tcmds.parent(NodeToeLift, NodeFootControl)\n\tcmds.parent(NodeFootLowerControl, NodeFootControlsRoot)\n\tcmds.parent(NodeFootUpperControl, NodeFootControlsRoot)\n\tcmds.parent(NodeFootControlsRoot, NodeToeLift)\n\tcmds.parent(NodeIKHandle, NodeFootUpperControl)\n\tcmds.parent(NodeUp, NodeRigRoot)\n\n\t#------------------------------------------------------------------------------\n\t# Zero Outs and Construction Constraints\n\n\tZeroByJointOrient(NodeFootLowerControl)\n\tZeroByJointOrient(NodeFootUpperControl)\n\tZeroByOffsetParentMatrix(NodeUp)\n\n\t#Set ToeLift Construction Zero\n\tsuffixTag = cmds.ls(NodeToeLift, shortNames=True)[0]\n\tAlignConst2 = cmds.createNode( 'baconAlign', n=('baconAlign_' + suffixTag))\n\tcmds.connectAttr(constructTip+'.worldMatrix', AlignConst2+'.targetWorldMatrix', f=True)\n\tcmds.connectAttr(NodeFootControl+'.worldMatrix', AlignConst2+'.parentWorldMatrix', f=True)\n\tWorldMatrix2 = cmds.createNode( 'baconMatrixCompose', n=('baconMatrixCompose_' + suffixTag ) )\n\tcmds.connectAttr(AlignConst2+'.alignedPosition', WorldMatrix2+'.translation', f=True)\n\tcmds.connectAttr(AlignConst2+'.alignedRotation', WorldMatrix2+'.EulerRotation', f=True)\n\tcmds.connectAttr(WorldMatrix2+'.outputMatrix', NodeToeLift+'.offsetParentMatrix', f=True)\n\tcmds.setAttr(NodeToeLift+'.translate', 0,0,0)\n\tcmds.setAttr(NodeToeLift+'.rotate', 0,0,0)\n\n\t#Set foot control root Construction Zero\n\tsuffixTag = cmds.ls(NodeFootControlsRoot, shortNames=True)[0]\n\tAlignConst = cmds.createNode( 'baconAlign', n=('baconAlign_' + suffixTag ))\n\tcmds.connectAttr(constructRoot+'.worldMatrix', AlignConst+'.targetWorldMatrix', f=True)\n\tcmds.connectAttr(NodeToeLift+'.worldMatrix', AlignConst+'.parentWorldMatrix', f=True)\n\tcmds.connectAttr(NodeFootControlsRoot+'.jointOrient', AlignConst+'.jointOrient', f=True)\n\tWorldMatrix3 = cmds.createNode( 'baconMatrixCompose', n=('baconMatrixCompose_' + suffixTag ))\n\tcmds.connectAttr(AlignConst+'.alignedPosition', WorldMatrix3+'.translation', f=True)\n\tcmds.connectAttr(AlignConst+'.alignedRotation', WorldMatrix3+'.EulerRotation', f=True)\n\tcmds.connectAttr(WorldMatrix3+'.outputMatrix', NodeFootControlsRoot+'.offsetParentMatrix', f=True)\n\tcmds.setAttr(NodeFootControlsRoot+'.translate', 0,0,0)\n\tcmds.setAttr(NodeFootControlsRoot+'.rotate', 0,0,0)\n\n\n\t#Set foot control Construction Zero\n\tsuffixTag = cmds.ls(NodeFootControl, shortNames=True)[0]\n\tAimConst = cmds.createNode( 'baconLookAt', n=('baconLookAt_' + suffixTag ))\n\tcmds.setAttr(AimConst+'.upAxis', 1)\n\tcmds.setAttr(AimConst+'.aimAxisFlip', BoneDirection)\n\tcmds.connectAttr(constructTip+'.worldMatrix', AimConst+'.targetWorldMatrix', f=True)\n\tcmds.connectAttr(NodeRigRoot+'.worldMatrix', AimConst+'.parentWorldMatrix', f=True)\n\tcmds.connectAttr(constructHeel+'.translate', AimConst+'.localPosition', f=True)\n\tWorldMatrix = cmds.createNode( 'baconMatrixCompose', n=('baconMatrixCompose_' + suffixTag ))\n\tcmds.connectAttr(constructHeel+'.translate', WorldMatrix+'.translation', f=True)\n\tcmds.connectAttr(AimConst+'.lookAtRotation', WorldMatrix+'.EulerRotation', f=True)\n\tcmds.connectAttr(WorldMatrix+'.outputMatrix', NodeFootControl+'.offsetParentMatrix', f=True)\n\n\n\t#------------------------------------------------------------------------------\n\t# Constraints\n\tcmds.orientConstraint(NodeFootUpperControl, NodeAnkle, maintainOffset=True)\n\tcmds.orientConstraint(NodeFootLowerControl, NodeToe, maintainOffset=True)\n\n\n\nsel = cmds.ls(absoluteName=True, orderedSelection=True, type=xForms)\nif sel != None:\n\tfor toe in sel:\n\t\tif getHierarchyLevel(toe) >= 3:\n\t\t\tautoRigReverseFoot(toe)\n" )
        -mip 2
        -mi "Arm IK (BaconIK) [BSPLUG]" ( "import maya.cmds as cmds\nimport maya.api.OpenMaya as om\nimport math, sys\nxForms = ['joint','transform']\n\nif cmds.pluginInfo('baconShapeBone', query=True, loaded=True) == False:\n\tcmds.loadPlugin('baconShapeBone')\n\ndef createBaconLocator( name='locator', xRay=1, shapeType=1, shapeColor=6 ):\n\tnewJoint = cmds.createNode('joint', n=name)\n\tcmds.setAttr(newJoint + '.drawStyle', 2)\n\tshapeName = cmds.ls(newJoint, shortNames=True)[0] + '_Shape'\n\tboneShape = cmds.createNode('baconShapeBone', parent=newJoint, n=shapeName)\n\tcmds.setAttr(boneShape+'.shapeType', shapeType)\n\tcmds.setAttr(boneShape+'.xRay', xRay)\n\tcmds.color(newJoint, ud=shapeColor)\n\treturn(newJoint)\n\ndef createBaconLine(nodeStart, nodeEnd):\n\tshapeName = cmds.ls(nodeStart, shortNames=True)[0] + '_LineShape'\n\tnextShape = cmds.createNode('baconShapeLine', parent=nodeStart, n=shapeName)\n\tcmds.setAttr(nextShape+'.lineType', 0) #wireColor0\n\tcmds.setAttr(nextShape+'.wireIntensity', 0.2)\n\tcmds.connectAttr(nodeStart+'.worldMatrix', nextShape+'.parentTM', f=True)\n\tcmds.connectAttr(nodeEnd+'.worldMatrix', nextShape+'.targetMatrix', f=True)\n\treturn(nextShape)\n\ndef getHierarchyLevel(node):\n\tGramps = None\n\tPops = node\n\tLevel = 0\n\twhile Gramps == None:\n\t\tnextPops = cmds.listRelatives(Pops, parent=True, path=True, type=xForms)\n\t\tif nextPops == None:\n\t\t\tGramps = Pops\n\t\telse:\n\t\t\tPops = nextPops[0]\n\t\t\tLevel += 1\n\treturn(Level)\n\t\ndef autoRigArmBaconIK(Hand):\n\t#------------------------------------------------------------------------------\n\t# AutoRig arm with BaconIK\n\t# sel = cmds.ls(absoluteName=True, orderedSelection=True, type=xForms)\n\t# Hand = sel[0]\n\tLowerArm = cmds.listRelatives(Hand, parent=True, path=True, type=xForms)[0]\n\tUpperArm = cmds.listRelatives(LowerArm, parent=True, path=True, type=xForms)[0]\n\tClavicle = cmds.listRelatives(UpperArm, parent=True, path=True, type=xForms)[0]\n\n\t# Get info on arm length and direction via Lowerarm\n\tBoneDirection = 0\n\tSetupColorID = 6\n\tDirectionSign = 1\n\tLowerarmLocalPos = om.MVector(cmds.xform(LowerArm, ws=False, t=True, query=True))\n\tif LowerarmLocalPos.x < 0:\n\t\tBoneDirection = 1\n\t\tSetupColorID = 8\n\t\tDirectionSign = -1\n\tArmLength = LowerarmLocalPos.length()  # measured by ulna length.\n\n\t# Get TMs and world positions\n\tUpperArmTM = cmds.xform(UpperArm, matrix=True, query=True, worldSpace=True)\n\tUpperArmPos = om.MVector(cmds.xform(UpperArm, ws=True, t=True, query=True))\n\tLowerArmTM = cmds.xform(LowerArm, matrix=True, query=True, worldSpace=True)\n\tLowerArmPos = om.MVector(cmds.xform(LowerArm, ws=True, t=True, query=True))\n\tHandTM = cmds.xform(Hand, matrix=True, query=True, worldSpace=True)\n\tHandPos = om.MVector(cmds.xform(Hand, ws=True, t=True, query=True))\n\n\t# Create Controls\n\tIKHandle = createBaconLocator( name=('IKHandle'), xRay=0, shapeType=8, shapeColor=SetupColorID )\n\tcmds.xform(IKHandle, matrix=HandTM, worldSpace=True)\n\tIKHandleScale = ArmLength / 4.0\n\tcmds.setAttr(IKHandle+'.shapeSize', IKHandleScale * 2.0, IKHandleScale, IKHandleScale )\n\tUpVector = createBaconLocator( name=('UpVector'), xRay=0, shapeType=4, shapeColor=SetupColorID )\n\n\t# Calc\n\tDir1 = LowerArmPos - UpperArmPos\n\tDir1.normalize()\n\tDir2 = HandPos - UpperArmPos\n\tDir2.normalize()\n\tDir3 = HandPos - LowerArmPos\n\tDir3.normalize()\n\tN = Dir2^Dir1\n\tN.normalize()\n\tBackDir = N^Dir3\n\tBackDir.normalize()\n\n\talignedUpTM = [ Dir3[0],Dir3[1],Dir3[2],0.0,\\\n\tBackDir[0],BackDir[1],BackDir[2],0.0, \\\n\tN[0],N[1],N[2],0.0, \\\n\tLowerArmTM[12], LowerArmTM[13], LowerArmTM[14], LowerArmTM[15] ]\n\n\t# mirror matrix alignment if negative side.\n\tif BoneDirection == 1:\n\t\tmirrorMatrix = [-1,-1,-1,1,  -1,-1,-1,1,  1,1,1,1,  1,1,1,1]\n\t\tfor j in range(16):\n\t\t\talignedUpTM[j] *= mirrorMatrix[j]\n\n\t# UpVector \n\tcmds.xform(UpVector, matrix=alignedUpTM, worldSpace=True)\n\tUpVectorScale = ArmLength / 8.0\n\tcmds.setAttr(UpVector+'.shapeSize', UpVectorScale, UpVectorScale, UpVectorScale)\n\tcreateBaconLine(UpVector, LowerArm)\n\tcmds.xform(UpVector, translation=(0,ArmLength*2.0*DirectionSign,0), relative=True, objectSpace=True)\n\n\t# Create IK\n\tBaconIK = cmds.createNode( 'bacon2BoneIK' )\n\tcmds.setAttr(BaconIK+'.BoneDirection', BoneDirection )\n\tcmds.connectAttr(IKHandle+'.worldMatrix', BaconIK+'.goalMatrix', f=True)\n\tcmds.connectAttr(UpVector+'.worldMatrix', BaconIK+'.upMatrix', f=True)\n\tcmds.connectAttr(Clavicle+'.worldMatrix', BaconIK+'.rootMatrix', f=True)\n\tcmds.setAttr(BaconIK+'.Bone1Length', ArmLength )\n\tcmds.setAttr(BaconIK+'.Bone2Length', om.MVector(cmds.xform(Hand, ws=False, t=True, query=True)).length() )\n\tUpperArmPos = cmds.xform(UpperArm, ws=False, t=True, query=True)\n\tcmds.setAttr(BaconIK+'.Bone1InitialPosition', UpperArmPos[0], UpperArmPos[1], UpperArmPos[2])\n\tcmds.connectAttr(UpperArm+'.jointOrient', BaconIK+'.Bone1Orient', f=True)\n\tcmds.connectAttr(LowerArm+'.jointOrient', BaconIK+'.Bone2Orient', f=True)\n\tcmds.setAttr(BaconIK+'.elbowTension', 0.5)\n\tcmds.setAttr(BaconIK+'.stretchIK', 1.0)\n\tcmds.setAttr(BaconIK+'.stretchBlend', 1.0)\n\n\n\t# Set Constraints\n\tcmds.orientConstraint(IKHandle, Hand, maintainOffset=True)\n\tcmds.connectAttr(BaconIK+'.Bone1Rotation', UpperArm+'.rotate', f=True)\n\tcmds.connectAttr(BaconIK+'.Bone2Rotation', LowerArm+'.rotate', f=True)\n\tcmds.connectAttr(BaconIK+'.Bone1StretchPosition', UpperArm+'.translate', f=True)\n\tcmds.connectAttr(BaconIK+'.Bone2StretchPosition', LowerArm+'.translate', f=True)\n\tcmds.connectAttr(BaconIK+'.handStretchPosition', Hand+'.translate', f=True)\n\nsel = cmds.ls(absoluteName=True, orderedSelection=True, type=xForms)\nif sel != None:\n\tfor hand in sel:\n\t\tif getHierarchyLevel(hand) >= 4:\n\t\t\tautoRigArmBaconIK(hand)" )
        -mip 3
        -mi "Arm IK (MayaIK)" ( "#------------------------------------------------------------------------------\n# AutoRig arm with MayaIK\nimport maya.cmds as cmds\nimport maya.api.OpenMaya as om\nimport math, sys\nxForms = ['joint','transform']\n\nif cmds.pluginInfo('baconShapeBone', query=True, loaded=True) == False:\n\tcmds.loadPlugin('baconShapeBone')\n\ndef createBaconLocator( name='locator', xRay=1, shapeType=1, shapeColor=6 ):\n\tnewJoint = cmds.createNode('joint', n=name)\n\tcmds.setAttr(newJoint + '.drawStyle', 2)\n\tshapeName = cmds.ls(newJoint, shortNames=True)[0] + '_Shape'\n\tboneShape = cmds.createNode('baconShapeBone', parent=newJoint, n=shapeName)\n\tcmds.setAttr(boneShape+'.shapeType', shapeType)\n\tcmds.setAttr(boneShape+'.xRay', xRay)\n\tcmds.color(newJoint, ud=shapeColor)\n\treturn(newJoint)\n\ndef createBaconLine(nodeStart, nodeEnd):\n\tshapeName = cmds.ls(nodeStart, shortNames=True)[0] + '_LineShape'\n\tnextShape = cmds.createNode('baconShapeLine', parent=nodeStart, n=shapeName)\n\tcmds.setAttr(nextShape+'.lineType', 0) #wireColor0\n\tcmds.setAttr(nextShape+'.wireIntensity', 0.2)\n\tcmds.connectAttr(nodeStart+'.worldMatrix', nextShape+'.parentTM', f=True)\n\tcmds.connectAttr(nodeEnd+'.worldMatrix', nextShape+'.targetMatrix', f=True)\n\treturn(nextShape)\n\ndef getHierarchyLevel(node):\n\tGramps = None\n\tPops = node\n\tLevel = 0\n\twhile Gramps == None:\n\t\tnextPops = cmds.listRelatives(Pops, parent=True, path=True, type=xForms)\n\t\tif nextPops == None:\n\t\t\tGramps = Pops\n\t\telse:\n\t\t\tPops = nextPops[0]\n\t\t\tLevel += 1\n\treturn(Level)\n\n#------------------------------------------------------------------------------\n# AutoRig arm with BaconIK\n\ndef autoRigArmMayaIK(Hand):\n\tLowerArm = cmds.listRelatives(Hand, parent=True, path=True, type=xForms)[0]\n\tUpperArm = cmds.listRelatives(LowerArm, parent=True, path=True, type=xForms)[0]\n\tClavicle = cmds.listRelatives(UpperArm, parent=True, path=True, type=xForms)[0]\n\n\t# Get info on arm length and direction via Lowerarm\n\tBoneDirection = 0\n\tSetupColorID = 6\n\tDirectionSign = 1\n\tLowerarmLocalPos = om.MVector(cmds.xform(LowerArm, ws=False, t=True, query=True))\n\tif LowerarmLocalPos.x < 0:\n\t\tBoneDirection = 1\n\t\tSetupColorID = 8\n\t\tDirectionSign = -1\n\tArmLength = LowerarmLocalPos.length()\n\n\t# Get TMs and world positions\n\tUpperArmTM = cmds.xform(UpperArm, matrix=True, query=True, worldSpace=True)\n\tUpperArmPos = om.MVector(cmds.xform(UpperArm, ws=True, t=True, query=True))\n\tLowerArmTM = cmds.xform(LowerArm, matrix=True, query=True, worldSpace=True)\n\tLowerArmPos = om.MVector(cmds.xform(LowerArm, ws=True, t=True, query=True))\n\tHandTM = cmds.xform(Hand, matrix=True, query=True, worldSpace=True)\n\tHandPos = om.MVector(cmds.xform(Hand, ws=True, t=True, query=True))\n\n\t# Create Controls\n\tIKHandle = createBaconLocator( name=('IKHandle'), xRay=0, shapeType=8, shapeColor=SetupColorID )\n\tcmds.xform(IKHandle, matrix=HandTM, worldSpace=True)\n\tIKHandleScale = ArmLength / 4.0\n\tcmds.setAttr(IKHandle+'.shapeSize', IKHandleScale * 2.0, IKHandleScale, IKHandleScale )\n\tUpVector = createBaconLocator( name=('UpVector'), xRay=0, shapeType=4, shapeColor=SetupColorID )\n\n\t# Calc\n\tDir1 = LowerArmPos - UpperArmPos\n\tDir1.normalize()\n\tDir2 = HandPos - UpperArmPos\n\tDir2.normalize()\n\tDir3 = HandPos - LowerArmPos\n\tDir3.normalize()\n\tN = Dir2^Dir1\n\tN.normalize()\n\tBackDir = N^Dir3\n\tBackDir.normalize()\n\n\talignedUpTM = [ Dir3[0],Dir3[1],Dir3[2],0.0,\\\n\tBackDir[0],BackDir[1],BackDir[2],0.0, \\\n\tN[0],N[1],N[2],0.0, \\\n\tLowerArmTM[12], LowerArmTM[13], LowerArmTM[14], LowerArmTM[15] ]\n\n\t# mirror matrix alignment if negative side.\n\tif BoneDirection == 1:\n\t\tmirrorMatrix = [-1,-1,-1,1,  -1,-1,-1,1,  1,1,1,1,  1,1,1,1]\n\t\tfor j in range(16):\n\t\t\talignedUpTM[j] *= mirrorMatrix[j]\n\n\t# UpVector \n\tcmds.xform(UpVector, matrix=alignedUpTM, worldSpace=True)\n\tUpVectorScale = ArmLength / 8.0\n\tcmds.setAttr(UpVector+'.shapeSize', UpVectorScale, UpVectorScale, UpVectorScale)\n\tcreateBaconLine(UpVector, LowerArm)\n\tcmds.xform(UpVector, translation=(0,ArmLength*2.0*DirectionSign,0), relative=True, objectSpace=True)\n\n\t# Set Constraints\n\tcmds.orientConstraint(IKHandle, Hand, maintainOffset=True)\n\tNodeIKHandle = cmds.ikHandle( sj=UpperArm, ee=Hand )\n\tcmds.parent(NodeIKHandle[0], IKHandle)\n\tcmds.poleVectorConstraint(UpVector, NodeIKHandle[0])\n\tcmds.select(IKHandle)\n\nsel = cmds.ls(absoluteName=True, orderedSelection=True, type=xForms)\nif sel != None:\n\tfor hand in sel:\n\t\tif getHierarchyLevel(hand) >= 4:\n\t\t\tautoRigArmMayaIK(hand)\n" )
        -mip 4
        -mi "Bendy Bones [BSPLUG]" ( "import maya.cmds as cmds\nimport maya.api.OpenMaya as om\nxForms = ['joint','transform']\n\nif cmds.pluginInfo('baconShapeRibbon', query=True, loaded=True) == False:\n\tcmds.loadPlugin('baconShapeRibbon')\nif cmds.pluginInfo('baconRibbon', query=True, loaded=True) == False:\n\tcmds.loadPlugin('baconRibbon')\n\nsel = cmds.ls(absoluteName=True, orderedSelection=True, type=xForms)\nselCount = len(sel)\nif selCount > 4:\n\tBezier1 = sel[0]\n\tTangent1 = sel[1]\n\tTangent2 = sel[2]\n\tBezier2 = sel[3]\n\tSegments = []\n\tfor i in range(4, selCount):\n\t\tSegments.append(sel[i])\n\tSegmentCount = len(Segments)\n\t\n\t#Segment Measurements\n\tstartPosition = om.MVector(cmds.xform(Bezier1, ws=True, t=True, query=True))\n\tendPosition = om.MVector(cmds.xform(Bezier2, ws=True, t=True, query=True))\n\tRibbonLength = (endPosition - startPosition).length()\n\tSegmentLength = RibbonLength / SegmentCount\n\tSegmentNorm = SegmentLength / RibbonLength\n\n\t#Ribbon Shape\n\tribbonShape = cmds.createNode('baconShapeRibbon', parent=Bezier1)\n\tcmds.connectAttr(ribbonShape+'.parentMatrix', ribbonShape+'.parentTM', f=True)\n\tcmds.connectAttr(Bezier1+'.worldMatrix', ribbonShape+'.startWorldMatrix', f=True)\n\tcmds.connectAttr(Tangent1+'.worldMatrix', ribbonShape+'.startTangentWorldMatrix', f=True)\n\tcmds.connectAttr(Tangent2+'.worldMatrix', ribbonShape+'.endTangentWorldMatrix', f=True)\n\tcmds.connectAttr(Bezier2+'.worldMatrix', ribbonShape+'.endWorldMatrix', f=True)\n\t\t\n\t#Segment setup\n\tfor s in range(SegmentCount):\n\t\tsegmentRibbon = cmds.createNode('baconRibbon', n=(cmds.ls(Segments[s], shortNames=True)[0] + '_Ribbon') )\n\t\tcmds.connectAttr(Bezier1+'.worldMatrix', segmentRibbon+'.startWorldMatrix', f=True)\n\t\tcmds.connectAttr(Tangent1+'.worldMatrix', segmentRibbon+'.startTangentWorldMatrix', f=True)\n\t\tcmds.connectAttr(Tangent2+'.worldMatrix', segmentRibbon+'.endTangentWorldMatrix', f=True)\n\t\tcmds.connectAttr(Bezier2+'.worldMatrix', segmentRibbon+'.endWorldMatrix', f=True)\n\t\tcmds.connectAttr(Segments[0]+'.parentInverseMatrix', segmentRibbon+'.parentInverseMatrix', f=True)\n\t\tcmds.setAttr(segmentRibbon+'.pathLength', SegmentNorm/2.0 )\n\t\tcmds.setAttr(segmentRibbon+'.pathPercent', (SegmentNorm * s) + (SegmentNorm/2.0) )\n\t\tcmds.connectAttr(Bezier1+'.rotateX', segmentRibbon+'.twistStart', f=True)\n\t\tcmds.connectAttr(Bezier2+'.rotateX', segmentRibbon+'.twistEnd', f=True)\n\t\tcmds.connectAttr(segmentRibbon+'.alignedPosition', Segments[s]+'.translate', f=True)\n\t\tcmds.connectAttr(segmentRibbon+'.alignedRotation', Segments[s]+'.rotate', f=True)\t\n" )
        -mip 5
        -mi "Bacon Double Bezier [BSPLUG]" ( "import maya.cmds as cmds\nimport maya.api.OpenMaya as om\nxForms = ['joint','transform']\n\nif cmds.pluginInfo('baconShapeRibbon', query=True, loaded=True) == False:\n\tcmds.loadPlugin('baconShapeRibbon')\nif cmds.pluginInfo('baconDoubleBezier', query=True, loaded=True) == False:\n\tcmds.loadPlugin('baconDoubleBezier')\n\t\nsel = cmds.ls(absoluteName=True, orderedSelection=True, type=xForms)\nselCount = len(sel)\nif selCount > 8:\n\tC0P0 = sel[0]\n\tC0P1 = sel[1]\n\tC0P2 = sel[2]\n\tC0P3 = sel[3]\n\tC1P0 = sel[4]\n\tC1P1 = sel[5]\n\tC1P2 = sel[6]\n\tC1P3 = sel[7]\n\tFeathers = []\n\tfor i in range(8, selCount):\n\t\tFeathers.append(sel[i])\n\tFeatherCount = len(Feathers)\n\tFeatherU = 1.0 / FeatherCount\n\n\t#Ribbon Shape 1\n\tribbonShape1 = cmds.createNode( 'baconShapeRibbon', parent=C0P0 )\n\tcmds.connectAttr(ribbonShape1+'.parentMatrix', ribbonShape1+'.parentTM', f=True)\n\tcmds.connectAttr(C0P0+'.worldMatrix', ribbonShape1+'.startWorldMatrix', f=True)\n\tcmds.connectAttr(C0P1+'.worldMatrix', ribbonShape1+'.startTangentWorldMatrix', f=True)\n\tcmds.connectAttr(C0P2+'.worldMatrix', ribbonShape1+'.endTangentWorldMatrix', f=True)\n\tcmds.connectAttr(C0P3+'.worldMatrix', ribbonShape1+'.endWorldMatrix', f=True)\n\t\n\t#Ribbon Shape 2\n\tribbonShape2 = cmds.createNode( 'baconShapeRibbon', parent=C1P0 )\n\tcmds.connectAttr(ribbonShape2+'.parentMatrix', ribbonShape2+'.parentTM', f=True)\n\tcmds.connectAttr(C1P0+'.worldMatrix', ribbonShape2+'.startWorldMatrix', f=True)\n\tcmds.connectAttr(C1P1+'.worldMatrix', ribbonShape2+'.startTangentWorldMatrix', f=True)\n\tcmds.connectAttr(C1P2+'.worldMatrix', ribbonShape2+'.endTangentWorldMatrix', f=True)\n\tcmds.connectAttr(C1P3+'.worldMatrix', ribbonShape2+'.endWorldMatrix', f=True)\n\t\t\n\t#Feather setup\n\tfor s in range(FeatherCount):\n\t\tbaconDoubleBezier = cmds.createNode('baconDoubleBezier', n=(cmds.ls(Feathers[s], shortNames=True)[0] + '_BaconDoubleBezier') )\n\t\tcmds.connectAttr(C0P0+'.worldMatrix', baconDoubleBezier+'.startCurve1WorldMatrix', f=True)\n\t\tcmds.connectAttr(C0P1+'.worldMatrix', baconDoubleBezier+'.startTangent1WorldMatrix', f=True)\n\t\tcmds.connectAttr(C0P2+'.worldMatrix', baconDoubleBezier+'.endTangent1WorldMatrix', f=True)\n\t\tcmds.connectAttr(C0P3+'.worldMatrix', baconDoubleBezier+'.endCurve1WorldMatrix', f=True)\n\t\tcmds.connectAttr(C1P0+'.worldMatrix', baconDoubleBezier+'.startCurve2WorldMatrix', f=True)\n\t\tcmds.connectAttr(C1P1+'.worldMatrix', baconDoubleBezier+'.startTangent2WorldMatrix', f=True)\n\t\tcmds.connectAttr(C1P2+'.worldMatrix', baconDoubleBezier+'.endTangent2WorldMatrix', f=True)\n\t\tcmds.connectAttr(C1P3+'.worldMatrix', baconDoubleBezier+'.endCurve2WorldMatrix', f=True)\n\t\tcmds.connectAttr(C1P0+'.rotateX', baconDoubleBezier+'.spinStart', f=True)\n\t\tcmds.connectAttr(C1P3+'.rotateX', baconDoubleBezier+'.spinEnd', f=True)\n\t\tcmds.connectAttr(Feathers[s]+'.parentInverseMatrix', baconDoubleBezier+'.parentInverseMatrix', f=True)\n\t\tcmds.connectAttr(Feathers[s]+'.jointOrient', baconDoubleBezier+'.jointOrient', f=True)\n\t\tFeatherPercent = (FeatherU / 2.0) + (FeatherU * s)\n\t\tcmds.setAttr(baconDoubleBezier+'.Curve1Percent', FeatherPercent )\n\t\tcmds.setAttr(baconDoubleBezier+'.Curve2Percent', FeatherPercent )\n\t\tcmds.connectAttr(baconDoubleBezier+'.Position', Feathers[s]+'.translate', f=True)\n\t\tcmds.connectAttr(baconDoubleBezier+'.Rotation', Feathers[s]+'.rotate', f=True)\n" )
        -mip 6
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "DynamicBones by Akasaki tools" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Physics" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "Phys" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "collision.png" 
        -image1 "collision.png" 
        -style "iconOnly" 
        -marginWidth 0
        -marginHeight 1
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
        -mi "Add Dynamics to Joint [AKASAKI]" ( "import pymel.core as pm\nimport maya.cmds as cmds\nimport pymel.core.datatypes as dt\n\ntime = pm.ls('time1')[0]\nSel = pm.selected()\nif cmds.pluginInfo('boneDynamicsNode', query=True, loaded=True) == False:\n\tcmds.loadPlugin('boneDynamicsNode')\n\nfor k in Sel:\n\tchildren = k.getChildren()\n\tif len(children) > 0:\n\t\tck = children[0]\n\t\tif (k.typeName() == 'joint') and (ck.typeName() == 'joint') :\n\t\t\tDynaNodeName = 'BoneDynamics_' + k.shortName()\n\t\t\tDynaNode = pm.createNode('boneDynamicsNode', n=DynaNodeName)\n\t\t\tpm.connectAttr(k.jointOrient, DynaNode.boneJointOrient, f=True)\n\t\t\tpm.connectAttr(k.inverseScale, DynaNode.boneInverseScale, f=True)\n\t\t\tpm.connectAttr(k.translate, DynaNode.boneTranslate, f=True)\n\t\t\tpm.connectAttr(ck.translate, DynaNode.endTranslate, f=True)\n\t\t\tpm.connectAttr(k.parentMatrix, DynaNode.boneParentMatrix, f=True)\n\t\t\tpm.connectAttr(k.parentInverseMatrix, DynaNode.boneParentInverseMatrix, f=True)\n\t\t\tpm.connectAttr(k.radius, DynaNode.radius, f=True)\n\t\t\tpm.connectAttr(k.scale, DynaNode.boneScale, f=True)\n\t\t\tpm.connectAttr(ck.scale, DynaNode.endScale, f=True)\n\t\t\tpm.connectAttr(time.outTime, DynaNode.time, f=True)\n\t\t\tpm.connectAttr(DynaNode.outputRotate, k.rotate, f=True)\n\n\npm.select(Sel)" )
        -mip 0
        -mi "Remove Dynamics to Joint [AKASAKI]" ( "import maya.cmds as cmds\nimport maya.api.OpenMaya as om\nxForms = ['joint','transform']\n\nif cmds.pluginInfo('boneDynamicsNode', query=True, loaded=True) == False:\n\tcmds.loadPlugin('boneDynamicsNode')\n\ntime = cmds.ls('time1')[0]\nsel = cmds.ls(absoluteName=True, orderedSelection=True, type=xForms)\nfor k in sel:\n\tDynaNodes = cmds.listConnections(k+'.rotate', source=True, type='boneDynamicsNode')\n\tcmds.delete(DynaNodes)\n" )
        -mip 1
        -mi "Add Sphere Joint Collision [AKASAKI]" ( "import maya.cmds as cmds\nxForms = ['joint','transform']\n\nif cmds.pluginInfo('boneDynamicsNode', query=True, loaded=True) == False:\n\tcmds.loadPlugin('boneDynamicsNode')\n\ntime = cmds.ls('time1')[0]\nsel = cmds.ls(absoluteName=True, orderedSelection=True, type=xForms)\nif len(sel) > 1:\n\tcolSphere = sel[0]\n\tfor i in range(1, len(sel)):\n\t\tDynaBone = sel[i]\n\t\tDynaNodes = cmds.listConnections(DynaBone+'.rotate', source=True, type='boneDynamicsNode')\n\t\tfor d in DynaNodes:\n\t\t\tnextID = 1\n\t\t\telements = cmds.getAttr(d+'.sphereCollider', multiIndices=True)\n\t\t\tif elements != None:\n\t\t\t\tnextID = elements[-1] + 1 # Lol it's 1-based. \n\t\t\tcmds.connectAttr( colSphere+'.worldMatrix', d+'.sphereCollider[' + nextID.__str__() + '].sphereColMatrix', f=True )\n\t\t\tcmds.connectAttr( colSphere+'.radius', d+'.sphereCollider[' + nextID.__str__() + '].sphereColRadius', f=True )\n" )
        -mip 2
        -mi "Add Capsule Joint Collision [AKASAKI]" ( "import maya.cmds as cmds\nxForms = ['joint','transform']\n\nif cmds.pluginInfo('boneDynamicsNode', query=True, loaded=True) == False:\n\tcmds.loadPlugin('boneDynamicsNode')\n\ntime = cmds.ls('time1')[0]\nsel = cmds.ls(absoluteName=True, orderedSelection=True, type=xForms)\nif len(sel) > 1:\n\tcolCapsule2 = sel[0]\n\tcolCapsule1 = cmds.listRelatives(colCapsule2, parent=True, path=True, type=xForms)[0]\n\tif (cmds.objectType(colCapsule1) ==  'joint') and (cmds.objectType(colCapsule2) == 'joint') :\n\t\tfor i in range(1, len(sel)):\n\t\t\tDynaBone = sel[i]\n\t\t\tDynaNodes = cmds.listConnections(DynaBone+'.rotate', source=True, type='boneDynamicsNode')\n\t\t\tfor d in DynaNodes:\n\t\t\t\tnextID = 1\n\t\t\t\telements = cmds.getAttr(d+'.sphereCollider', multiIndices=True)\n\t\t\t\tif elements != None:\n\t\t\t\t\tnextID = elements[-1] + 1 # Lol it's 1-based. \n\t\t\t\tcmds.connectAttr( colCapsule1+'.worldMatrix', d+'.capsuleCollider[' + nextID.__str__() + '].capsuleColMatrixA', f=True )\n\t\t\t\tcmds.connectAttr( colCapsule1+'.radius', d+'.capsuleCollider[' + nextID.__str__() + '].capsuleColRadiusA', f=True )\n\t\t\t\tcmds.connectAttr( colCapsule2+'.worldMatrix', d+'.capsuleCollider[' + nextID.__str__() + '].capsuleColMatrixB', f=True )\n\t\t\t\tcmds.connectAttr( colCapsule2+'.radius', d+'.capsuleCollider[' + nextID.__str__() + '].capsuleColRadiusB', f=True )\n\n" )
        -mip 3
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "PreHeat Translation + Rotation" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "BakeTR" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "TR" 
        -overlayLabelColor 1 0.536275 0.314 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "baconPreheat_shelf.png" 
        -image1 "baconPreheat_shelf.png" 
        -style "iconOnly" 
        -marginWidth 0
        -marginHeight 1
        -command "import maya.cmds as cmds\nimport maya.api.OpenMaya as om\nxForms = ['joint','transform']\n\ndef MMatrixToMatrix(TM):\n\treturn([TM[0],TM[1],TM[2],TM[3],TM[4],TM[5],TM[6],TM[7],TM[8],TM[9],TM[10],TM[11],TM[12],TM[13],TM[14],TM[15]])\n\n# Plugin is loaded\nif cmds.pluginInfo('baconShapeBone', query=True, loaded=True) == False:\n\tcmds.loadPlugin('baconShapeBone')\n\nsel = cmds.ls(absoluteName=True, orderedSelection=True, type=xForms)\nif len(sel)\t> 1:\n\tsourceNode = sel[0]\n\ttargetNode = sel[1]\n\tbakeNodeName = 'BakeInstruction_' + (cmds.ls(targetNode)[0])\n\tbakeNode = cmds.createNode('baconPreheat', n=bakeNodeName)\n\tcmds.setAttr(bakeNode+'.bakePosition', True)\n\tcmds.setAttr(bakeNode+'.bakeRotation', True)\n\tif cmds.objectType(targetNode) == 'joint':\n\t\tcmds.connectAttr( targetNode+'.jointOrient', bakeNode+'.jointOrient', f=True )\n\tcmds.connectAttr( targetNode+'.parentInverseMatrix', bakeNode+'.parentInverseMatrix', f=True )\n\tcmds.connectAttr( sourceNode+'.worldMatrix', bakeNode+'.targetWorldMatrix', f=True )\t\n\ttargetTM = om.MMatrix(  cmds.xform(targetNode, ws=True, matrix=True, query=True)  )\n\tsourceTM = om.MMatrix(  cmds.xform(sourceNode, ws=True, matrix=True, query=True)  )\n\toffsetTM = targetTM * sourceTM.inverse()\n\tcmds.setAttr( bakeNode+'.offsetMatrix', MMatrixToMatrix(offsetTM), type=\"matrix\")\n\tcmds.connectAttr( targetNode+'.message', bakeNode+'.drivenNode', force=True )\n\tcmds.connectAttr( sourceNode+'.message', bakeNode+'.driverNode', force=True  )\n" 
        -sourceType "python" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Preheat Rotation" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "BakeR" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "R" 
        -overlayLabelColor 0.275 0.543419 1 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "baconPreheat_shelf.png" 
        -image1 "baconPreheat_shelf.png" 
        -style "iconOnly" 
        -marginWidth 0
        -marginHeight 1
        -command "import maya.cmds as cmds\nimport maya.api.OpenMaya as om\nxForms = ['joint','transform']\n\ndef MMatrixToMatrix(TM):\n\treturn([TM[0],TM[1],TM[2],TM[3],TM[4],TM[5],TM[6],TM[7],TM[8],TM[9],TM[10],TM[11],TM[12],TM[13],TM[14],TM[15]])\n\n# Plugin is loaded\nif cmds.pluginInfo('baconShapeBone', query=True, loaded=True) == False:\n\tcmds.loadPlugin('baconShapeBone')\n\nsel = cmds.ls(absoluteName=True, orderedSelection=True, type=xForms)\nif len(sel)\t> 1:\n\tsourceNode = sel[0]\n\ttargetNode = sel[1]\n\tbakeNodeName = 'BakeInstruction_' + (cmds.ls(targetNode)[0])\n\tbakeNode = cmds.createNode('baconPreheat', n=bakeNodeName)\n\tcmds.setAttr(bakeNode+'.bakePosition', False)\n\tcmds.setAttr(bakeNode+'.bakeRotation', True)\n\tif cmds.objectType(targetNode) == 'joint':\n\t\tcmds.connectAttr( targetNode+'.jointOrient', bakeNode+'.jointOrient', f=True )\n\tcmds.connectAttr( targetNode+'.parentInverseMatrix', bakeNode+'.parentInverseMatrix', f=True )\n\tcmds.connectAttr( sourceNode+'.worldMatrix', bakeNode+'.targetWorldMatrix', f=True )\t\n\ttargetTM = om.MMatrix(  cmds.xform(targetNode, ws=True, matrix=True, query=True)  )\n\tsourceTM = om.MMatrix(  cmds.xform(sourceNode, ws=True, matrix=True, query=True)  )\n\toffsetTM = targetTM * sourceTM.inverse()\n\tcmds.setAttr( bakeNode+'.offsetMatrix', MMatrixToMatrix(offsetTM), type=\"matrix\")\n\tcmds.connectAttr( targetNode+'.message', bakeNode+'.drivenNode', force=True )\n\tcmds.connectAttr( sourceNode+'.message', bakeNode+'.driverNode', force=True  )\n" 
        -sourceType "python" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Bake" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Bake" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "baconBake_shelf.png" 
        -image1 "baconBake_shelf.png" 
        -style "iconOnly" 
        -marginWidth 0
        -marginHeight 1
        -command "import maya.cmds as cmds\nimport maya.api.OpenMaya as om\nxForms = ['joint','transform']\nif cmds.pluginInfo('baconPreheat', query=True, loaded=True) == False:\n\tcmds.loadPlugin('baconPreheat')\n\n# progress bar\ngMainProgressBar = maya.mel.eval('$tmp = $gMainProgressBar');\ncmds.progressBar( gMainProgressBar, edit=True, beginProgress=True, isInterruptable=True, status='\"Baking preheat instructions ...', maxValue=12 )\ncmds.progressBar( gMainProgressBar, edit=True, step=1 )\n\n# Step 1, find all bake instructions\nallBakeInstructions = cmds.ls(type='baconPreheat')\n\n# Step 2, connect all constraint types\nallDriven = []\nDrivenTR = []\nDrivenR = []\n# bakeNode = allBakeInstructions[0]\nif len(allBakeInstructions) > 0:\n\tfor bakeNode in allBakeInstructions:\n\t\tif cmds.objectType(bakeNode) != type(None):\n\t\t\tdrivenNode = cmds.listConnections(bakeNode+'.drivenNode')[0]\n\t\t\tif cmds.objectType(drivenNode) != type(None):\n\t\t\t\tcmds.lockNode(bakeNode, lock=True)\n\t\t\t\tif cmds.getAttr(bakeNode+'.bakeRotation'):\n\t\t\t\t\tcmds.connectAttr( bakeNode+'.alignedRotationX', drivenNode+'.rotateX', f=True )\n\t\t\t\t\tcmds.connectAttr( bakeNode+'.alignedRotationY', drivenNode+'.rotateY', f=True )\n\t\t\t\t\tcmds.connectAttr( bakeNode+'.alignedRotationZ', drivenNode+'.rotateZ', f=True )\n\t\t\t\t\tif cmds.getAttr(bakeNode+'.bakePosition'):\n\t\t\t\t\t\tcmds.connectAttr( bakeNode+'.alignedPositionX', drivenNode+'.translateX', f=True )\n\t\t\t\t\t\tcmds.connectAttr( bakeNode+'.alignedPositionY', drivenNode+'.translateY', f=True )\n\t\t\t\t\t\tcmds.connectAttr( bakeNode+'.alignedPositionZ', drivenNode+'.translateZ', f=True )\n\t\t\t\t\t\tDrivenTR.append(drivenNode)\n\t\t\t\t\t\t#print( 'TR Added: ', drivenNode.getName() )\n\t\t\t\t\telse:\n\t\t\t\t\t\tDrivenR.append(drivenNode)\n\t\t\t\t\t\t#print( 'R  Added: ', drivenNode.getName() )\n\t\t\t\t\tallDriven.append(drivenNode)\n\t\t\n# Step 3 Profit\nif len(allBakeInstructions) > 0:\n\ttimeRange = (cmds.playbackOptions( animationStartTime=True, query=True ), cmds.playbackOptions( animationEndTime=True, query=True ))\n\tif len(DrivenR) > 0:\n\t\tcmds.bakeResults( DrivenR,  t=timeRange, at=[\"rotate\"], hi=\"none\" )\n\tcmds.progressBar( gMainProgressBar, edit=True, step=8 )\n\tif len(DrivenTR) > 0:\n\t\tcmds.bakeResults( DrivenTR, t=timeRange, at=[\"rotate\", \"translate\"], hi=\"none\")\n\tcmds.progressBar( gMainProgressBar, edit=True, step=10 )\n\t\n\tfor bakeNode in allBakeInstructions:\n\t\tif cmds.objectType(bakeNode) != type(None):\n\t\t\tdrivenNode = cmds.listConnections(bakeNode+'.drivenNode', source=True )\n\t\t\tif cmds.objectType(drivenNode) != type(None):\n\t\t\t\tcmds.lockNode(bakeNode, lock=False)\n\t\t\t\t\n\tprint('Preheat bake complete!')\n\tcmds.progressBar(gMainProgressBar, edit=True, endProgress=True)\n\tcmds.progressBar( gMainProgressBar, edit=True, step=11 )\n\tcmds.confirmDialog( title='Baking complete.', message='Bacon-strip completed baking preheat objects.', button=['Ok'] )\n" 
        -sourceType "python" 
        -commandRepeatable 1
        -flat 1
        -mi "Preview Bake [BSPLUG]" ( "import maya.cmds as cmds\nimport maya.api.OpenMaya as om\nxForms = ['joint','transform']\nif cmds.pluginInfo('baconPreheat', query=True, loaded=True) == False:\n\tcmds.loadPlugin('baconPreheat')\n\nallBakeInstructions = cmds.ls(type='baconPreheat')\nallDriven = []\n# bakeNode = allBakeInstructions[1]\nif len(allBakeInstructions) > 0:\n\tfor bakeNode in allBakeInstructions:\n\t\tif cmds.objectType(bakeNode) != type(None):\n\t\t\tdrivenNode = cmds.listConnections(bakeNode+'.drivenNode')[0]\n\t\t\tif cmds.objectType(drivenNode) != type(None):\n\t\t\t\tif cmds.getAttr(bakeNode+'.bakeRotation'):\n\t\t\t\t\tcmds.connectAttr( bakeNode+'.alignedRotationX', drivenNode+'.rotateX', f=True )\n\t\t\t\t\tcmds.connectAttr( bakeNode+'.alignedRotationY', drivenNode+'.rotateY', f=True )\n\t\t\t\t\tcmds.connectAttr( bakeNode+'.alignedRotationZ', drivenNode+'.rotateZ', f=True )\n\t\t\t\t\tif cmds.getAttr(bakeNode+'.bakePosition'):\n\t\t\t\t\t\tcmds.connectAttr( bakeNode+'.alignedPositionX', drivenNode+'.translateX', f=True )\n\t\t\t\t\t\tcmds.connectAttr( bakeNode+'.alignedPositionY', drivenNode+'.translateY', f=True )\n\t\t\t\t\t\tcmds.connectAttr( bakeNode+'.alignedPositionZ', drivenNode+'.translateZ', f=True )\n\t\t\t\t\tallDriven.append(drivenNode)" )
        -mip 0
        -mi "Stop Preview [BSPLUG]" ( "import maya.cmds as cmds\nimport maya.api.OpenMaya as om\nxForms = ['joint','transform']\nif cmds.pluginInfo('baconPreheat', query=True, loaded=True) == False:\n\tcmds.loadPlugin('baconPreheat')\n\nallBakeInstructions = cmds.ls(type='baconPreheat')\nif len(allBakeInstructions) > 0:\n\tfor bakeNode in allBakeInstructions:\n\t\tif cmds.objectType(bakeNode) != type(None):\n\t\t\tcmds.lockNode(bakeNode, lock=True)\n\t\t\tdrivenNode = cmds.listConnections(bakeNode+'.drivenNode')[0]\n\t\t\tif cmds.objectType(drivenNode) != type(None):\n\t\t\t\tif cmds.getAttr(bakeNode+'.bakeRotation'):\n\t\t\t\t\tif cmds.isConnected( bakeNode+'.alignedRotationX', drivenNode+'.rotateX' ):\n\t\t\t\t\t\tcmds.disconnectAttr( bakeNode+'.alignedRotationX', drivenNode+'.rotateX' )\n\t\t\t\t\tif cmds.isConnected( bakeNode+'.alignedRotationY', drivenNode+'.rotateY' ):\n\t\t\t\t\t\tcmds.disconnectAttr( bakeNode+'.alignedRotationY', drivenNode+'.rotateY' )\n\t\t\t\t\tif cmds.isConnected( bakeNode+'.alignedRotationZ', drivenNode+'.rotateZ' ):\n\t\t\t\t\t\tcmds.disconnectAttr( bakeNode+'.alignedRotationZ', drivenNode+'.rotateZ' )\n\t\t\t\t\tif cmds.getAttr(bakeNode+'.bakePosition'):\n\t\t\t\t\t\tif cmds.isConnected( bakeNode+'.alignedPositionX', drivenNode+'.translateX' ):\n\t\t\t\t\t\t\tcmds.disconnectAttr( bakeNode+'.alignedPositionX', drivenNode+'.translateX' )\n\t\t\t\t\t\tif cmds.isConnected( bakeNode+'.alignedPositionY', drivenNode+'.translateY' ):\n\t\t\t\t\t\t\tcmds.disconnectAttr( bakeNode+'.alignedPositionY', drivenNode+'.translateY' )\n\t\t\t\t\t\tif cmds.isConnected( bakeNode+'.alignedPositionZ', drivenNode+'.translateZ' ):\n\t\t\t\t\t\t\tcmds.disconnectAttr( bakeNode+'.alignedPositionZ', drivenNode+'.translateZ' )\n\t\t\tcmds.lockNode(bakeNode, lock=False)\n\n\n\n\n\n\n" )
        -mip 1
        -mi "Remove Preheat (selection) [BSPLUG]" ( "import maya.cmds as cmds\n\nif cmds.pluginInfo('baconPreheat', query=True, loaded=True) == False:\n\tcmds.loadPlugin('baconPreheat')\n\nsel = cmds.ls(absoluteName=True, orderedSelection=True, type=xForms)\nfor k in Sel:\n\tpreheats = cmds.listConnections(k+'.message', destination=True, type='baconPreheat') \n\tif len(preheats) > 0:\n\t\tcmds.delete(preheats)\n\n\n\n\n" )
        -mip 2
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Skin Tools and Paint weights on smooth bound skins" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "Skin" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "baconstripSkin_shelf.png" 
        -image1 "baconstripSkin_shelf.png" 
        -style "iconOnly" 
        -marginWidth 0
        -marginHeight 1
        -command "ArtPaintSkinWeightsTool;" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
        -mi "Paint Skin Weights" ( "ArtPaintSkinWeightsTool;" )
        -mi "Deactivate Skin" ( "import maya.cmds as cmds\nxForms = ['joint','transform']\n\ndef setSkinActive(isActive):\n\tNow = cmds.currentTime( query=True )\n\tcmds.currentTime( 0, update=True, edit=True )\n\tsel = cmds.ls(absoluteName=True, orderedSelection=True, type=xForms)\n\tfor k in sel:\n\t\tmeshes = cmds.listRelatives(k, type='mesh')\n\t\tfor m in meshes:\n\t\t\tskins = cmds.listConnections(m, type='skinCluster')\n\t\t\tfor s in skins:\n\t\t\t\tcmds.skinCluster(s, edit=True, moveJointsMode=(not isActive))\n\tcmds.currentTime( Now, update=True, edit=True )\n\nsetSkinActive(False)\n" )
        -mip 1
        -mi "Activate Skin" ( "import maya.cmds as cmds\nxForms = ['joint','transform']\n\ndef setSkinActive(isActive):\n\tNow = cmds.currentTime( query=True )\n\tcmds.currentTime( 0, update=True, edit=True )\n\tsel = cmds.ls(absoluteName=True, orderedSelection=True, type=xForms)\n\tfor k in sel:\n\t\tmeshes = cmds.listRelatives(k, type='mesh')\n\t\tfor m in meshes:\n\t\t\tskins = cmds.listConnections(m, type='skinCluster')\n\t\t\tfor s in skins:\n\t\t\t\tcmds.skinCluster(s, edit=True, moveJointsMode=(not isActive))\n\tcmds.currentTime( Now, update=True, edit=True )\n\nsetSkinActive(True)\n" )
        -mip 2
    ;

} 
